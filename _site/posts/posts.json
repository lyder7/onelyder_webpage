[
  {
    "path": "posts/new-post-r/",
    "title": "Sammendrag Funksjoner i R",
    "description": "Vektorer, lister, loops og purrr. En oversikt over sentrale emner.",
    "author": [
      {
        "name": "Lyder ~ onelyder",
        "url": {}
      }
    ],
    "date": "2022-02-02",
    "categories": [],
    "contents": "\n\nContents\nOversikt over sentrale tidyverse pakker. Kartlegge bruksområder.\nBasis: Vektorer & strukturer i R\nBasis: String funksjoner sentrale\n\nTopics\nViktige basis konsepter\nSymboler\nLogiske sjekk-punkter\nLoops\npurrr::map\npurrr::map: forskjeller\n\nFunksjonell programmering i R\nTidyverse\nOppsett\n\nPurrr\nmap\nimap, pmap\nFunksjoner jeg har laget selv\n\nSideeffetcs\nEgne funksjoner\nLage\n\nrlang\nNoen tips\n\nC++ og R?\nNest\n\n\nAppendix\nRefernaser\n\nOversikt over sentrale tidyverse pakker. Kartlegge bruksområder.\nBasis: Vektorer & strukturer i R\nKonsepter du må forstå eller akseptere for å beherske funksjoner, loops og representative opperasjoner med R kode.\nUansett hvor kompleks en funksjon eller script fremstår, vil det i bunn og grunn bestå av mange sekvenser av relativt simple og “enkle” argumenter og funksjoner fra basisen. De absolutt viktigste og mest kritiske tar vi for oss nå.\nLær dem!\njennybc.github.io/purrr-tutorial\nVector\nSamme klasse, en eller flere.\nData.frame\nSamling av flere vektorer, som vi kaller kollonner, bestående av samme eller ulike type klasser i hver vetkor/kolonne.\nListe\nFlere eller samme klasse i vektorene, kompleks.\nBasis: String funksjoner sentrale1\nBrukes ofte i funksjoner til å printe feks navnet til en funksjon, operasjon eller indeks som referanse. Lek litt med disse og forstå hva slags type output paste og past0 lager. 2\npaste()\npaste0()\nTopics\nBasis Konsepter\nViktige basis konsepter\nSymboler\nLogiske sjekk-punkter\nViktige basis konsepter\nSelv om tidyverse og alle dens fantastiske hjelpemidler til R brukere, er det alikevel etter min mening viktig å lære de fundamentale rammene. Dette kalles “base R”.\nFunksjonene er standard og tilgjengelig for alle som laster ned R. Det er ikke behov for å laste ned base R, slik man må gjøre med andre pakker. For base R er kommandoene allerede tilgjengelig og kan brukes.\nDet er forøvrig flere standard-pakker som følger med. utils, stats, methods, grDevices, graphics og datasets.\nFra R-studio kan man få en oversikt over pakkene, og se hva dem inneholder. Hvis man går til vinduet og klikker på menyen som heter “Enviroment”. Der vil det stå “Global Enviorment”. Trykk på rull-gardinen og det vil komme frem en oversikt over pakkene jeg nevnte over. Velg feks base.\nDet er mulig å redigere hvordan informasjonen vises. Helt til høyre i vinduet er det en ny rullegardin med en pil som peker ned, siden av oppdater-symbolet. Grid og List er alternativene. Personlig foretrekker jeg den første, fordi den viser informasjon over flere kolonner.\nFra oversikten kan du undersøke hvilke funksjoner som er tilgjengelig. Man kan også se kilde-koden. Muligheten til å se hvordan funksjonene er bygget opp er utrloig nyttig når man utvikler ferdighetene innenfor programmering. Kilde koden gir muligens svaret man trenger for å konkretisere eller gi en klar definisjon på hvordan funksjonen/kommandoen fungerer.\nLink Base R\nInne i R-studio, finn pakken library. Åpne funksjonen.\nDet gir et perspektiv om hva som ligger bak funksjonene som brukes regelmessig.\nSymboler\nDette er notasjoner og syboler det er nyttig å lære. Bruken av disse kan potensielt gjøre funksjonene du skriver enda mer dynamiske og sterke. Her er noen av de symbolene jeg personlig ønsker å lære mer om:\ndo.call(function_name, object_name)\n%>% –> margitrrr. Chain-operator.\n%in%\n\\n\n\\t\n[[ ]] –> vector\n[ ] –> list\nLogiske sjekk-punkter\nifelse base\nif_else dplyr\nall() base. Kan brukes på flere måter:\nalene all(logical0==)) if(all(0)) –> Hvis alle verdiene definert av funksjonenen så skjer:\n\n\nobject_a = NULL\nobject_b = NULL\nif(all(object_a == object_b)){\nprint(\"the objects are the same\")\n} else {\n peint(\"they are not true\")\n}\n\n\n\nNB!! Husk at vi kan tweake funksjonen ved\n\n\nobject_a = NULL\nobject_b = NULL\nif(!all(object_a == object_b)){\nprint(\"hello worlf\")\n} else {\n print(\"statemant not true\")\n}\n\n\n\nDet er også mulig å gjøre flere essesnielle justeringer av funksjonen. Over skrev vi kun else, som vil si at hvis if-statementen først resulterer i FALSE, så vil den gå over til neste oppgave som er definert etter\nelse {\n} ``\nHvis vi legger inn bare en liten endring og skriver else if () gjør vi slik at programmet vurderer en ny logisk test før den utfører en spesiell type oppgave. Dette er for å kontrollere funksjonens rute. Ofte er det nødvendig med avklaringer, og dersom noe aviker (som det testest for i if utsagnene) vil programmet rettet det opp.\nDette kalles control flow innenfor funksjonell programmering. Her er noen snipps som viser else if varianten:\n\nobject_a = NULL\nobject_b = NULL\n# 1\nif(all(object_a == object_b)){\nprint(\"the objects are the same\")\n} else if{\n print(\"they are not true\")\n}\nobject_a = NULL\nobject_b = TRUE\n# 2\n if(!all(object_a == object_b)){\nprint(\"hello worlf\")\n} else if( {\n print(\"statemant not true\")\n}\n\nNB else må vøre på samme linje som den siste brakken { for at R skal kunne avaluere den. Hvis du skriver\nLogic checkpoints\nBygge funksjoner er alfa-omega med koding. Det å kunne lage- og bygge opp sine egne funksjoner er en superkraft. I utgangspunktet kan man fint bruke funksjoner som allerede finnes i pakker. Som regel er de aller fleste pakkene innenfor ulike fagfelt/emner store i omfang, slik at de dekker de fleste verktøyene man vil trenge for en analyse feks.\nMen sannsynligheten for at et problem som ikke helt kan løses med pakken du bruker, er funksjonsbygging løsningen!\nKonseptet om at det er mulig å gi et obejekt x <- \"hva_som_helst\". Altså, vi kan lagre tekst, tall eller funksjoner etc. inne i en sytste-variabel vi kaller x. Det som gjør det kanskje enda mer forvirrende er at hvis vi lagrer variabelen som en funksjon, så kan den funksjonen i prinsippet bestå av hva som helst. Det er dette som gjør det fantastisk.\nLoops\nEksempel purrr\nEksempelet under viser et vanlig scenario hvor loops vil være naturlig å bruke. Målet er å telle antall bokstaver i hvert navn i vektoren “names”.\nVidere følger vi god praksis ved å gjøre klar objektet resultatene skal lagres i. I dette tilfellet er det antall bokstaver i hvert navn.\n\n\nnavn <- c(\"Lyder\", \"Aleksander\", \"Mathisen\")\nn_ord <- vector(\"double\", length(navn)) # Expecting double\n\n\n\nVidere lager vi en loop som utfører opperasjonen i en bolk. Årsaken til at man bruker loops er fordi man ønsker å unngå repitasjon. Det er ikke bra å gjenta seg selv. Derfor skriver man heller en loop som gjør alt vi ønsker i en bolk slik som under.\n\n\nfor(i in seq_along(navn)) {\n  n_ord[[i]] <- stringr::str_extract(navn[[i]], \"\\\\w\") # Returns character\n}\nn_ord\n\n\n\nFor hvert element i, i antall sekvenser i vektoren \\(`navn`\\), utfør funksjonen str_extraxt() på objektet navn[]indeks i, lagre resultatet i objektet \\(`n_ord`\\) indeks \\(`i`\\).\nResultatet er altså: vi får et objekt n_ord bestående av antall bokstaver (resultatet) for hvert navn. I dette tilfellet er det 3 navn, som bestyr 3 resultater.\nOBS FEIL I EKSEMPLET\npurrr::map\nEksemplet over viser hvordan loops kan utføres. Dette er den tradisjonelle måten å gjøre det på. Man kaller det ofte “basis R forloops”.\nKonseptet loops3 innenfor programmering generelt sett er et viktig og veletablert tema eller konsept. For språk som C, C# og C++ eller Python er loops spessielt “the way” og på mange måter en del av flowen i spåket for de som bruker det som deres nummer1 språk.\nC++ er feks kjent som det aller raskeste og effektive språket. Særlig for oppgaver hvor loops er nyttig. For R derimot er det spesielt for kritikere av R, et godt etablert sannhet at loops går treigt. Sammenlignet med da feks C++.\nSå klart har det i realiteten ingenting å si for små prosjekter eller analyser. Men satt i perspektiv; det er ikke effektivt å skrive loops i R.\nÅrsaken er kompleks og mer sammensatt til å forklare det enkelt og intuitivt. Men det har rot i hvordan syn-tak-strukturen i R er bygget opp, og antall linjer/bokstaver, samt objekter som er nødvendig å skrive for å utføre funksjoner eller representative operasjoner.\nLøsningen på dette problemet er purrr fra tidyverse pakken for R.\npurrr er en pakke som tar for seg funksjonell programmering spesifikt med R-kode. Pakken har utviklet konsepter og metoder som gjør at vi faktisk kan utføre oppgaver og operasjoner hvor loops i utgangspunktet hadde vært en del av løsningen. Du kan betrakte det som en måte å gjøre loops på, uten å skrive loops. Merkelig nok..\nDet du isteden burde gjøre for å forstå dette konseptet er å tenkte på representative operasjoner som skal gjøres for alle elementene i objektet. Altså at noe skal utføres flere ganger på flere ulike elementer innenfor et objekt vi undersøker/analyserer. 4\npurrr::map: forskjeller\ni in seq_along(object) erstattes med .x\nmap utfører loopen med hensyn til hva slags class .x er.\nVektor, data.frame eller liste er derfor av betydning!\n{ body }erstattes med .f\nfunksjonen eller oppgaven som skal utføres\nmap()er hovedfunksjonen.\nMen det er noen hjelpere for å garantere/kontrollere output:\nmap_dbl()\nmap_chr()\nmap_int()\nmap_dfr()\nwalk()\nFunksjonell programmering i R\nTidyverse\nPurrr er en pakke fra Tidyverse paradigme som hjelper til med funksjonelle operasjoner. Ved bruk av tidy prinsippene hjelper purrr oss med å utføre operasjoner på en effektiv måte. Alternativet er å skrive egne funksjoner. Risikoen ved egne funksjoner er at outputen er kanskje riktig for den spesifikke settingen funksjonen lages. Men over tid og ved gjenbruk på andre data sett kan den gi resultater som muligens er feil. I dette kapittelet er formålet å bli bedre kjent med purrr og se på scenarioer hvor purrr kan være et nyttig hjelpemiddel.\nOppsett\nTil å starte med laster vi inn tidyverse. Alternativ er det også mulig å laste inn purrr ved library(purrr).\n\n\nlibrary(tidyverse)\n\n\n\nVidere trenger vi et datasett som vi kan bruke underveis. I tidyverse pakken finnes et datasett som heter iris. Dersom tidyverse er lastet inn er det mulig å referere til datasettet. Det har vi allerede gjort, og av den grunn lagrer jeg iris under navnet data_iris. Se kodesnipp under:\n\n\ndata_name <- iris %>% \n  as_tibble()\ndata_name \n\n\n\nKoden over viser hvordan data-settet “iris” kan refereres til etter at tidyverse er lastet inn. Videre ser vi at iris blir lagret i en variabel vi kaller data_name. I prinsippet kunne vi valgt å “døpe” datasettet til noe annet. Og til slutt ser vi at de 10 første radene i datasettet kommer frem når vi skiver data_name til konsollen. Her er formålet å få et kjapt overblikk over hvordan datan ser ut.\nPurrr\nmap\nFor å bli kjent med data er det fra base R vanlig å utføre funksjonen class(). Den gir tilbake informasjon om hvilke klasser datasettet består av. Dersom vi utfører class(data_name) får vi som output data.frame. Det er fordi class() funksjonen kjøres på objektet data_name som helhet. Noen ganger kan det være nyttig å få informasjon om hver variabel, som blir det samme som hver kolonne i et data sett.\nEn løsning er å gjøre slik:\nclass(class(data_name$Sepal.Length)) eller class(data_name[,1]). Ulempen med denne måten er at den er treg og lite effektiv. For å sjekke neste kolonne må vi skrive class(data_name[,2]) etc. helt frem til vi har testet alle variablene vi er interessert i. I praksis vil det være alle kolonnene i et datasett.\nMed purrr pakken kan vi sjekke alle kolonne med en funksjon og en linje med kode. Tilbake gir den oss en vektor med resultatet fra alle variablene/ kolonnene i datasettet som vi har lagret som “data_name”. Se under:\n\n\nmap_chr(data_name, class)\n\n\n\nÅrsaken til at vi bruker map_chr er fordi outputen blir fremvist i et objekt lagret som “character” class. Til vanlig og som defoult lagres output fra map() funksjoner i lister. Det vil si at vi kan gjøre akkurat det samme med denne syntaksen:\n\n\nmap(data_name, class)\n\n\n\nMen her får vi resultatet lagret i en liste. Lister er mer komplisert å jobbe med, og er generelt vanskeligere å referere til i etterkant. Derfor ønsker vi å gjøre det så enkelt som mulig, å dermed bruke map_chr() som lagrer det for oss i en character class.\nVi kan også lagre outputen og referere til den i etterkant hvis vi trenger det. Under gjør vi eksakt samme operasjon, utfører class() funksjonen til alle variablene i datasettet data_name. Vi lagrer resultatet i data_name_classes. Videre bruker vi pipe fra magrittr til å utføre funksjonen glimpse() som gir oss en oppsummering-tabell av innholdet. Se under:\n\n\ndata_name_classes <- map_chr(data_name, class)\ndata_name_classes %>% \n  glimpse()\n\n\n\nLogikken med map er at den tar inn noen viktige input i funksjonen. Den etterspør .x og .f\n.x = en vektor som en funksjon skal utføres på\n.f = funksjonen som skal utføres.\nI vårt tilfelle er .x = data_name og .f = class .\nimap, pmap\nFunksjoner jeg har laget selv\nI denne delen tar jeg for meg egne funksjoner og skisser skrevet av meg selv. Målet er å videre uvikle dem og sette de til verks.\n\n\n#Info om hvilken mappe data ligger i + navn p? sheets \npath <- \"data_raw/mussample_Hias_How2o_interim.xlsx\"\nsheets <- readxl::excel_sheets(path)\n## Alle sheets i excelark er data.frames\npurrr::walk(\n  .x = excel_sheets(path),\n  .f = function(x) {\n    new_nm <- tolower(x)\n    assign(new_nm, read_excel(path, sheet = x), envir = .GlobalEnv)\n  }\n)\n\n\n\nBryte ned til flere deler er nok lurt å gjøre.\n1 består av data inn. Det kan være et excel ark med flere sheets som er aktuelt. Fra mitt eksempel kan det være regnskapsdata bestående av kolonner med tall, tekst og dato. Ofte er disse filene store for selskaper i en visse størrelser. Vi ønsker derfor å laste inn data slik at hver flik blir ett data.frame objekt i R, som kan brukes videre.\n\n# nest kan være neste steg. HVer data.frame er ett element i samme liste. Bruke det til å refere til for en loop-opperasjon. \n# Her er hva jeg tenker vist med en for looop:\nfor(i in seq(walk_object)){\n  \n  df[[i]] <- walk_object[[i]]\n  \n  a <- df\n  \n  if(!class(df)){\n    \n    # Data formattering starter\n    a <- a %>% \n      \n      \n      # Data frame class\n      tidyr::as_tibble()\n    \n      if(is.na(NA) = TRUE){\n        \n        drop_na(a)\n      }\n    \n    else{\n      \n      \n      \n      \n      \n    }\n      return(a)\n    \n  }\n  # freq antall varaibler/kolonner\n  if(count_(names(a)) == freq){\n    \n      kolonne_nanv <- names(a)\n      \n      # Velg kolonner \n      select(all_of(kolonne_navn)) %>% \n        \n      arrange(desc(.x)) %>% \n      \n      ##lage kolonne med diff \n      mutate(endring_periodeV = (sb2021 - sb2020))\n  }\n      if(desc(.x)) {\n        drop_na(NA %==% .x) %>%\n          else {\n            return(navn_her)\n            \n          }\n          mutate()\n      }\n      \n      drop_na(NA %==% .x) %>% \n      \n      \n      ## Regnskapskontoer i SB\n      \n    mutate(str_glue(konto_navn) == filter(vroom::starts_with(kolonne_navn)))\n      \n  }\n}\n# Dette kan gjøres med purrr og tidyr \ntidyr::nest()\n\nNeste steg er å generalisere opperasjonene som skal gjøres excell arkene. Første spørsmål: er opperasjonen lik for alle data-sett og alle kolonner?\npurrr ersatter loops laget selv\ndplyr for manipulering\nstringr for tekst\ntidyr for modellering, spesseilt lister\nSideeffetcs\nWalk funksjonen til purrr er en variant som brukes når funksjonen implementert har/ikke en output type som kalles sideeffekt. Output generelt kan beskrives i form av utsende; tabell, tall og annen tekst som er resultatet fra en operasjon utført via en funksjon som i sum utfører en rekke betinget rekkefølge med kommandoer og andre underliggende funksjoner som skaper objekter eller resultater, som printes ut i sin form i konsollen. Det betyr at vi kan se hva resultatet er, i form av konsoll-tekst.\nMotsetningen er at vi har funksjoner som gir output uten side effekter. Her gjør funksjon operasjoner som er utenfor dens “scope”. Eksempler er ploter eller genereringen av excel-sheets til en ny arbeidsbok som lages i R.\nDisse resultatene, fra ikke siden-effekt funksjons typer er at man ikke kan lagre resultatet i et objekt som kan refereres til i etterkant. Output er til motsetning slik at den vises frem i konsollen i en mer fysisk form. Enten som en graf, plot.\nÅrsaken til at dette er viktig å få med seg, er fordi output og hva funksjoner vi faktisk bruker, er utrolig viktig for å programmere effektivt.\nF.eks med funksjonen addWorksheet funksjonen, så gir den ingenting av output. Den endrer noe “utenfor scopet”.\nEgne funksjoner\nI dette kapittelet tar vi et steg videre. Jeg vil forsøke å vise- og lære hvordan man kan lage sine helt egne funksjoner. I prinsippet er alle funksjoner mulig å lage. Funksjoner har en fast form som vi skal se nærmere på her. Hvis denne formen følges, er det som et utgangspunkt opp til deg som forfatteren av funksjonen, hva den skal bestå av.\nI de første kapitalene var vi innom det grunnleggende konseptet hvor man ved bruk av <- eller = kan “lagre” data i objektet som vi selv velger hva skal hete. a <- 1 feks. Det vil si at a representerer tallet 1, og hver gang vi bruker a, vil det bli lest og tolket som 1.\nLage\nI utgangspunktet er det flere tusen funksjoner tilgjengelig som kan brukes. Som regel vil man komme langt med disse. Men som regel er det noen særtrekk med akkurat ditt problem, som funksjonen i pakken ikke evaluerer slik du ønsker. Det kan være flere grunner til det, men en typisk årsak til å skrive egne funksjoner kontra bruke andre sine, er for å tilpasse funksjonaliteten til problemet som du skal løse. Det er mest sans behov for noen tweaks og små justeringer. Men det kan også være tilfellet hvor det ikke finnes noe fra før, så man skriver hele funksjonen- og kanskje en hel pakke, for å løse problemet.\nJeg tar derfor først for meg standariserte funksjoner som er spesielle og egnet til å bruke i nye funksjoner også.\nrlang\nFor å gå litt dybere til verks for å forstå hva salgs hjelpemiddler og funksjoner som er i pakkene jeg personlig bruker til funksjoner og funksjonell prgrammering i R. I kodesnippen under tar jeg å henter ut funksjonsnavnene i pakken rlang, margitr, og purrr. Jeg lagrer disse i et objekt, og sammenligner dem mot hverandre.\n\n\npac <- pacman::p_functions(package = \"rlang\") %>% \n  as_vector() \n \npur <- pacman::p_functions(package = \"purrr\") %>% \n  as_vector()\nmag <- pacman::p_functions(package = \"magrittr\") %>% \n  as_vector()\n\n\n\n\n\ndf <- cbind(pac, pur, mag) %>% \n  as_tibble() %>% \n  glimpse()\n\n\n\nÅrsaken til denne sammenligningnen er for å indentifisere nyttige kontroll-funksjoner vi kan bruke når vi bygger opp våre egne. Logiske funksjoner som er TRUE eller FALSE er et velkjent konsept for programmerere. Det brukes til å kontrollere flownen og det som skjer inne i {}.\nSom nevnt tidligere er R og andre språk avhengig av rekkefølgen på hvordan ting gjøres. Resultatet av noe, vil påvirke et objekt, som vil ha konsekvenser for videre flyt. For å hindre at feil objekter, eller data typer taes inn videre, gjør man derfor if statement.\nDet vil si at inne i funksjonen vil det være en egen if evaluering. Dersom den logiske testen = TRUE vil den slippe inn i brakke t4egenne. Dersom FALSE hopper den over denne delen.\n\n\nfunction(x){\n  if(is.character(x)){\n  \n  }\n  return(x)\n}\n\n\n\nSom kode snippen viser over, er det altså en egen seksjon som er betinget av if testen.\nNoen tips\n\n\n# Lager en vektor med elemtener\nvector <- c(\"Lyder\", \"Aleksander\", \"Mathisen\")\n# Lønsing 1 \n\"Lyder\" %in% vector\n#Løsning 2\nany(vector == \"Lyder\")\nany(vector == \"Henrik\")\n\n\n\nKode snippen viser et typisk scenario hvor vi ønsker å sjekke om en vector består av en spesifikk verdi. I tilfellet jeg skrev over laget jeg bare en vektor bestående av navnet mitt. Det vil si det er tre separate elementer i vektoren. Under, løsning 1, tester jeg om “Lyder” er i vektor. Svaret er TRUE. Men et tips er å bruke løsning 2. Den gjør det samme, men er mer effektiv og standardisert. Det er derfor best practice å ta i bruk denne. Resultatet blir TRUE her også. Nederst tok jeg med evaluering av et element som ikke er en del, bare for å vise at denne resulterer FALSE.\nC++ og R?\nNoen spesifikke operasjoner er mer effektivt å gjøre med C++. R har gode løsninger som kobler språkene sammen, slik at det mest nødvendige oppgavene kan kjøres i C++ program, men hvor det allikevel skrives i R studio slik du er vant til. Pakken Rcppfikser dette for oss. Under trekker jeg ut funksjoner:\n\n\nlibrary(Rcpp)\npacman::p_functions(package = \"Rcpp\")\n\n\n\nNest\ntidyr::nest()\nAppendix\nRefernaser\n\nBrukes inne i funksjoner gjennom å printe feks navnet til en funksjon, opperasjon eller indeks som referanse.↩︎\nString manipulator. Typiske oppgaver som slå sammen to navn, separere ett ord til to ord, skille to ord med en valgt symbol “\\” etc. er eksempel på scenarioer disse brukes.↩︎\nloops, foreloops, whileloops, nestetloops etc.↩︎\nPrøv å unngå vrangforestillinger og missforståelser rundt ordet “loops”. Tenk på det som noe vi skal utføre flere ganger på forskjellige enheter.↩︎\n",
    "preview": {},
    "last_modified": "2022-02-02T22:35:47+01:00",
    "input_file": "new-post-r.knit.md"
  },
  {
    "path": "posts/loops-r/",
    "title": "Loops, map og funksjoner i R",
    "description": "Excel-relaterte problemstillinger, som blir løst med R kode. Funksjoner, loops og map blir disktuert og vist eksempler fra.",
    "author": [
      {
        "name": "Lyder Aleksander Mathisen",
        "url": "https://onelyder.com/posts/func-loops/"
      }
    ],
    "date": "2022-01-12",
    "categories": [],
    "contents": "\n\nContents\nNotater fra Bruno Rodriges\nNoen basis ting først\n\nFunksjonell programmering i R\nwalk og map\nGenerelt om loops\nMap istedenfor loops\n\n\n\nNotater fra Bruno Rodriges\nDenne lille spalten er inspirert av Bruno Rodriguez sin video Don’t write loops in R.\nVidere har jeg fylt på med noen ideer og tanker jeg har om temaet. Men først laster jeg inn pakkene som trengs for å kjøre igjennom det jeg har tenkt å vise frem. Kode-snippen under laster inn det som trengs, hvor spesielt tidyxl, openxlsx og readxl har unike funksjoner tilpasset for excel.\n\n\nlibrary(tidyverse)\nlibrary(tidyxl)\nlibrary(openxlsx)\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(readxl)\nlibrary(here)\n\n\n\nDe andre pakkene som purrr og dplyr er spesielt egnet for det funksjonelle operasjonene som skal foretas, etter data-filene er lastet inn og formatert. Den siste pakken here er alltid kjekk, fordi den hjelper til med å si ifra til konsollen hvor arbeids mappen vår er, slik at vi kan bruke relative referanser underveis. Altså ~/. Tidyverse gir totalen, den laster inn alle pakkene, som består av totalt 30 pakker utviklet av Hadley Wickham. Se mer om tidyverse her\nNoen basis ting først\nNoen “basis” ting som er nyttig:\n\".\" —> betyr i “dette området”. Altså mappen PCen din befinner seg i. Arbeids mappen.\nHer ser dere et eksempel hvor jeg bruker en funksjon list.files og bruker “.” som argument for hvilken path den skal lete i. I tillegg spesifiserer jeg hvilken filtype jeg ønsker å lete etter.\n\n\nlist.files(\".\", pattern = \".xlsx\")\n\n\n[1] \"demo_workbook.xlsx\"                          \n[2] \"top2000.xlsx\"                                \n[3] \"UK Labour Market - Sickness and Absence.xlsx\"\n[4] \"Uk Labour Productivity - Time Series.xlsx\"   \n[5] \"UK Public Service Productivity.xlsx\"         \n\nMen jeg kunne også spesifisert at jeg vil lete i et spesifikt område i arbeidsmappen min. For eksempel hvis jeg har en mappe som heter “data” hvor jeg har alle data-filene mine inne i. For eksempel excel ark.\n\n\nlist_data <- list.files(\".\", pattern = \".xlsx\")\nlist_sheets <- paste0(\"sheet_\", seq(1, length(list_data)))\n\nmy_excel_workbook <- createWorkbook()\n\n\n\nFunksjonell programmering i R\nwalk og map\nHva er forskjellen mellom walk og map? Og når skal man bruke dem?\nwalk gjør noe utenfor sitt scope –> ikke noe objekt som blir lagret. Den gir altså ikke et objekt som man kan referer til senere. Slik man feks kan gjøre dersom man skriver for eksempel a <- “objekt”. Etter å ha kjørt igjennom den kommandoen, vil “objekt” bli printet ut i konsollen hvis jeg skriver bare a.\nSlik er det altså ikke med walk. Den utfører operasjoner som resulterer i typiske outputs som vil vise noe. Ett plot eller som under ett excel ark, som vi senere kan skrive ut som en .xlsxfil for eksmepel. Men før vi gjør noe med det, kan vi ikke “se” det nødvendigvis.\n\n\nlist_sheets %>% \n  walk(~addWorksheet(my_excel_workbook, sheetName = .))\n\n\n\nDet er flere utgaver av denne funksjonen, som når det er 2 objekter vi trenger å utføre funksjonen med. Den kalles walk2, og er fra samme pakke purrr.\nwalk2 brukes når vi trenger ta inn flere objekter.\n\n\nwalk2(.x = list_sheets,\n      .y = list_data,\n      ~writeData(my_excel_workbook,\n                sheet = .x,\n                x = .y ))\n\n\n\nGenerelt om loops\nEt nytt eksempel er for å undersøke antall formler som finnes i et excel dokument, eller dokumenter vi ønsker å jobbe med. Det kan være jobb/skole relaterte Excel-filer.\n\n\nlist_xlsx <- list.files(\".\", pattern = \".xlsx\")\n\n\n\nFørst kan jeg sjekke en spesifikk Excel ark. Da spesifiserer i kommandoen under at det er fra list_xlsx[3] det er info jeg vil ha. Og list_xlsx[3] vil være det samme som navnet til Excel fila.\nDet som videre skjer er at vi tar i bruk noen nyttige funksjoner fra tidyxl pakken. xlsx_cells sammen med filter, og !i s.na gjør at denne kodenippen gir oss tilbake formler.\n\n\nxlsx_cells(list_xlsx[3]) %>%\n  filter(!is.na(formula)) %>% \n  head() %>% \n  pull(formula)\n\n\ncharacter(0)\n\nOver ser dere hvile former som er aktuelle. Nå har jeg brukt head(), så da vises bare de første elementene. Men her får vi et eksempel på hvilke formler. I denne går det i VLOOKUP som dere ser over.\nNoe annet nyttig er å finne ut hvor mange formler det er snakk om. Altså hvor mange celler i Excel arket vi jobber med består av formler. Kodesnippen under er bare en listen justering fra den forrige, ved at vi nå sier nrow() som gir antall rader.\n\n\nxlsx_cells(list_xlsx[3]) %>%\n  filter(!is.na(formula)) %>% \n nrow()\n\n\n[1] 0\n\nMen vi kan generalisere dette i en så kalt “fore loop”. Det betyr at i istedenfor å skrive inn hvilken vil vi ønsker, altså list_xlsx[3].. osv, kan vi heller loope over alle og lagre svarene i et objekt. Med andre ord, vi kan få resultatene fra alle arkene i ett objekt, i en operasjon.\nNår man skal lage loops på den klassiske måten, er det viktig å først huske å lage et objekt som vi kan lagre resultatene i. Her lager jeg objektet results som er en numerisk vektor bestående av 0, og har samme lenge som objektet vi tar inn list_xlsx. Som forøvrig i dette tilfellet er 7. Altså 7 filnavn.\n\n\nresults <- rep(0, length(list_xlsx))\n\n\nfor(i in seq_along(list_xlsx)){\n  results[i] <- xlsx_cells(list_xlsx[i]) %>%\n    filter(!is.na(formula)) %>% \n    nrow()\n}\nprint(results)\n\n\n[1] 0 0 0 0 0\n\nLoopen gjør det samme for alle xlsx filene. Den sjekker hvor mange celler er det som inneholder formler. Svarene lagres i results objektet. Og resultatet er at vi nå vet at det er \\[3\\] som har 2159, dem andre har ingen.\nMen vi vil også kanskje vite navnet på filene. Det kan vi fikse. Vi må bare gjøre en liten justering, trikse og mikse litt. Se under\n\n\nresults <- cbind(rep(0, length(list_xlsx)), 0)\n\nfor(i in seq_along(list_xlsx)){\n  results[i, 1] <- list_xlsx[i]\n  results[i, 2] <- xlsx_cells(list_xlsx[i]) %>%\n    filter(!is.na(formula)) %>% \n    nrow()\n}\n\nresults\n\n\n     [,1]                                           [,2]\n[1,] \"demo_workbook.xlsx\"                           \"0\" \n[2,] \"top2000.xlsx\"                                 \"0\" \n[3,] \"UK Labour Market - Sickness and Absence.xlsx\" \"0\" \n[4,] \"Uk Labour Productivity - Time Series.xlsx\"    \"0\" \n[5,] \"UK Public Service Productivity.xlsx\"          \"0\" \n\nNå fikk jeg et svar som består av 2 kolonner. Nå vet jeg hvilken Excel fil det gjelder, og jeg vet også hvor mange formler det er i den gitte filen.\nVidere kan man justere dette enda mer for å gjøre det mer oversiktigling og ordentlig. Her konverterer jeg bare svarene vi fikk om til en data.frame, fordi det opprinnelig var en matrix. Videre tar jeg bare å bruker funksjonen rename for å endre kolonnenavn. Det er akkurat samme svar, bare presentert på en annen måte. Mer ryddig og ordentlig.\n\n\ndata.frame(results) %>% \n  rename(\"Excel fil\"=X1,\n         \"Antall formler\"=X2) %>% \n  print()\n\n\n                                     Excel fil Antall formler\n1                           demo_workbook.xlsx              0\n2                                 top2000.xlsx              0\n3 UK Labour Market - Sickness and Absence.xlsx              0\n4    Uk Labour Productivity - Time Series.xlsx              0\n5          UK Public Service Productivity.xlsx              0\n\nMap istedenfor loops\nJeg skal nå viser dere hvordan alt det vi har gjort over kan gjøres på en enda mer effektiv og enklere måte. Vi utnytter purrr sine funksjonelle verktøy som tillater oss å gjøre eksakt det samme som vi ville gjort ved bruk av en loop, bare at vi trenger å skrive mye mindre kode.\nFørst vil jeg kjapt vise hva map gjør. Under tar jeg kvadratroten av alle tallene i sekvensen 1 til 10. Så den tar inn seq(1,10), som er det samme som et int-objekt. Det ville sett slik ut: int [1:10] 1 2 3 4 5 6 7 8 9 10 Videre utfører den funksjonen sqrt, som er en innebygget funksjon for kvadratrot. x, √{x}.\n\n\nmap(seq(1, 10), sqrt)\n\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 1.414214\n\n[[3]]\n[1] 1.732051\n\n[[4]]\n[1] 2\n\n[[5]]\n[1] 2.236068\n\n[[6]]\n[1] 2.44949\n\n[[7]]\n[1] 2.645751\n\n[[8]]\n[1] 2.828427\n\n[[9]]\n[1] 3\n\n[[10]]\n[1] 3.162278\n\nsteg 1\nVi må definere en formel. Dette er en generell formel, og kan brukes i realiteten for alle Excel ark videre. Den lagrer vi globalt i systemet våres.\n\n\ncount_formulas <- function(workbook_name){\n  n_formulas <- xlsx_cells(workbook_name) %>%\n    filter(!is.na(formula)) %>% \n    nrow()\n  \n  data.frame(\"workbook\" = workbook_name,\n             \"n_formulas\" = n_formulas)\n}\n\n\n\nsteg 2\nDet neste vi gjør er å bruke map. Jeg skal vise dere to måter. Den første er standard, men den gir en liste tilbake, som noen ganger er konrglete å jobbe med.\n\n\nmap(list_xlsx, count_formulas)\n\n\n[[1]]\n            workbook n_formulas\n1 demo_workbook.xlsx          0\n\n[[2]]\n      workbook n_formulas\n1 top2000.xlsx          0\n\n[[3]]\n                                      workbook n_formulas\n1 UK Labour Market - Sickness and Absence.xlsx          0\n\n[[4]]\n                                   workbook n_formulas\n1 Uk Labour Productivity - Time Series.xlsx          0\n\n[[5]]\n                             workbook n_formulas\n1 UK Public Service Productivity.xlsx          0\n\nDerfor finnes det en utgave av map som heter map_dfr. Den gir oss eksakt det samme svaret som vi gjorde over, til og med har den fiksa kolonnenavnene for oss. Det er fordi jeg spesifiserte i funksjonen vi lagde over at kallenavnene skal være workbook og n_formules. Det kan endres til hva enn som passer hvis man ønsker det.\n\n\nmap_dfr(list_xlsx, count_formulas)\n\n\n                                      workbook n_formulas\n1                           demo_workbook.xlsx          0\n2                                 top2000.xlsx          0\n3 UK Labour Market - Sickness and Absence.xlsx          0\n4    Uk Labour Productivity - Time Series.xlsx          0\n5          UK Public Service Productivity.xlsx          0\n\nVidere kan man være mer interessert å finne ut av egenskaper. Feks ønsker vi å vite hvilke filer har null formler i seg. Under legger jeg til en liten ekstra linje. Og sier gi meg svarer hvor det er null formler.\n\n\nmap_dfr(list_xlsx, count_formulas) %>% \n  filter(n_formulas == 0)\n\n\n                                      workbook n_formulas\n1                           demo_workbook.xlsx          0\n2                                 top2000.xlsx          0\n3 UK Labour Market - Sickness and Absence.xlsx          0\n4    Uk Labour Productivity - Time Series.xlsx          0\n5          UK Public Service Productivity.xlsx          0\n\nAngående loops\nDet er også scenario hvor det å faktisk skrive en klassisk loop er den beste løsningen. For eksempel hvis du jobber med en funksjon hvor det n´e element avhenger av den n´e. Referanse klikk her\nI tillegg er det flere verktøy rettet mot loops. I denne artikkelen har jeg fokusert på purrrr, men det er også furrr. furrr\n\n\n\n",
    "preview": {},
    "last_modified": "2022-01-30T20:38:32+01:00",
    "input_file": {}
  },
  {
    "path": "posts/git_devlab/",
    "title": "Gitlab",
    "description": "Bash scripting",
    "author": [
      {
        "name": "Lyder Aleksander Mathisen",
        "url": "https://onelyder.com/about"
      }
    ],
    "date": "2021-12-21",
    "categories": [],
    "contents": "\ngit kommandoer\nTerminal kommandor for git. Under er nyttig kommandoer i forbindelse med branching av et prosjekt. Det vil si at det er en developer gren (branch) som parralelt med main (hoved) grenen av prosjektet foretar endringer til nye tilskudd/endringer.\n\n# Lager ny branch \ngit branch from_startC dfed6bbc35053063a9b999d08170bb7b8c124504\n# Åpne branch \ngit checkout from_startC \n# print ut hvilken bracnh\ngit symbolic-ref HEAD\ngit add .\ngit commit -m \"commit text\"\n# Push til branchen \ngit push --set-upstream origin from_startC\n\n\n# Oversikt over commits\ngit log --graph \n#avslutt log modus \nshift + Q\n\n\n\n\n",
    "preview": {},
    "last_modified": "2022-01-29T23:11:31+01:00",
    "input_file": {}
  },
  {
    "path": "posts/linker_mappe/",
    "title": "Oppbevaring av sykt matriale",
    "description": "Gammelt versjon, se Refs seksjonen.",
    "author": [
      {
        "name": "Lyder Aleksander Mathisen",
        "url": "https://onelyder.com/about"
      }
    ],
    "date": "2021-10-21",
    "categories": [],
    "contents": "\n\nContents\nmyweblibrary 4later\nPodcasts - Coding/Programming\nR in General\nWeb\n\nPakker\nGenerelle standard\nData Manipulation/Formatting\nrmarkdown i R:\nShiny\nworkflow i R:\nAPI\n\n\nR-code & Packages\nPackages, functions & librarys available in R\nR-Markdown & Reproducable Reasearch\nData Wrangeling\nStatistical/Econometric models\nFinance, Risk, Timeseries, Optimization functions\nBlogroll: Finance & R-code\n\nGenerelle Notes\nFile types, how to store them and key differences\n\nCSV[x] XLS[x] zip[] gz[] tsv[] txt[]\nIntro (START)\nRefs to my own work stored some_where\n\n\nmyweblibrary 4later\nPodcasts - Coding/Programming\nCoder Radio\nGoogle podcast\n\nCommand-line Heroes\nRedhat radio\n\nr-weekly -Apple\nShiny developer Series\nApple\nCodingblocks Resources\nbrew\nR in General\nHADLEY WICKHAM\nrweekly\nrladies\nshinydevseries.com\nunleash-shiny.rinterface.com\nhttps://peertube.linuxrocks.online/videos/trending\nemilhvitfeldt.com\nWeb\nDestill Github Guide\nhttps://distillery.rbind.io/\nhttps://www.jhelvy.com/\nDenne Githuben er sykt bra!\nhttps://ellakaye.github.io/distilltools/\nhttps://github.com/seankross/postcards\nHugo Web Page\nepirhandbook R bok\nLegendarisk bok om alt rundt R kode.\nhttps://user2021.r-project.org/\nRstudio Cloud\nPakker\ncheatsheets R pakker\nGenerelle standard\nhere fs git2r Tidyverse devtools pacman remotes renv\nData Manipulation/Formatting\ndplyr lubridate stringr purrr tidyr\nreadr readxl opsenxlsx vroom # import csv or tsv tidyxl rio # import all type of files janitor # ename collums\nrmarkdown i R:\nbookdown blogdown knitr rmarkdown bs4 # bootstrap theme bslib # themes reprex # downlit # themes destill/rmkardown web tidytex # latex pack for R articls # article templates rmarkdown postcards # themes destill/web R distill # webpage rmarkdown kableExtra # kable print rmakrdown flextable # rmarkdown dashboard vtable # summary tables\nShiny\nshinyWidgets, dreamRs/shinyWidgets shinyjs, daattali/shinyjs shinydashboard, rstudio/shinydashboard shinydashboardPlus, RinteRface/shinydashboardPlus shinythemes, rstudio/shinythemes plotly, ploty/ploty dygraphs, rstudio/dygraphs highcharter, jbkunst/highcharter\nweb/html-output helpers:\njsonlite\nworkflow i R:\ntargets\ndrake\nAPI\nplumbr\n\n\n# Pakker jeg bruker \n\n##########################################\n# List of useful epidemiology R packages #\n##########################################\n\n# This script uses the p_load() function from pacman R package, \n# which installs if package is absent, and loads for use if already installed\n\n\n# Ensures the package \"pacman\" is installed\nif (!require(\"pacman\")) install.packages(\"pacman\")\n\n\n# Packages available from CRAN\n##############################\npacman::p_load(\n  \n  # learning R\n  ############\n  learnr,   # interactive tutorials in RStudio Tutorial pane\n  swirl,    # interactive tutorials in R console\n  \n  # project and file management\n  #############################\n  here,     # file paths relative to R project root folder\n  rio,      # import/export of many types of data\n  openxlsx, # import/export of multi-sheet Excel workbooks \n  \n  # package install and management\n  ################################\n  pacman,   # package install/load\n  renv,     # managing versions of packages when working in collaborative groups\n  remotes,  # install from github\n  \n  # General data management\n  #########################\n  tidyverse,    # includes many packages for tidy data wrangling and presentation\n  #dplyr,      # data management\n  #tidyr,      # data management\n  #ggplot2,    # data visualization\n  #stringr,    # work with strings and characters\n  #forcats,    # work with factors \n  #lubridate,  # work with dates\n  #purrr       # iteration and working with lists\n  linelist,     # cleaning linelists\n  naniar,       # assessing missing data\n  \n  # statistics  \n  ############\n  janitor,      # tables and data cleaning\n  gtsummary,    # making descriptive and statistical tables\n  rstatix,      # quickly run statistical tests and summaries\n  broom,        # tidy up results from regressions\n  lmtest,       # likelihood-ratio tests\n  easystats,\n  # parameters, # alternative to tidy up results from regressions\n  # see,        # alternative to visualise forest plots \n  \n  # epidemic modeling\n  ###################\n  epicontacts,  # Analysing transmission networks\n  EpiNow2,      # Rt estimation\n  EpiEstim,     # Rt estimation\n  projections,  # Incidence projections\n  incidence2,   # Make epicurves and handle incidence data\n  i2extras,     # Extra functions for the incidence2 package\n  epitrix,      # Useful epi functions\n  distcrete,    # Discrete delay distributions\n  \n  \n  # plots - general\n  #################\n  #ggplot2,         # included in tidyverse\n  cowplot,          # combining plots  \n  # patchwork,      # combining plots (alternative)     \n  RColorBrewer,     # color scales\n  ggnewscale,       # to add additional layers of color schemes\n  \n  \n  # plots - specific types\n  ########################\n  DiagrammeR,       # diagrams using DOT language\n  incidence2,       # epidemic curves\n  gghighlight,      # highlight a subset\n  ggrepel,          # smart labels\n  plotly,           # interactive graphics\n  gganimate,        # animated graphics \n  \n  \n  # gis\n  ######\n  sf,               # to manage spatial data using a Simple Feature format\n  tmap,             # to produce simple maps, works for both interactive and static maps\n  OpenStreetMap,    # to add OSM basemap in ggplot map\n  spdep,            # spatial statistics \n  \n  # routine reports\n  #################\n  rmarkdown,        # produce PDFs, Word Documents, Powerpoints, and HTML files\n  reportfactory,    # auto-organization of R Markdown outputs\n  officer,          # powerpoints\n  \n  # dashboards\n  ############\n  flexdashboard,    # convert an R Markdown script into a dashboard\n  shiny,            # interactive web apps\n  \n  # tables for presentation\n  #########################\n  knitr,            # R Markdown report generation and html tables\n  flextable,        # HTML tables\n  #DT,              # HTML tables (alternative)\n  #gt,              # HTML tables (alternative)\n  #huxtable,        # HTML tables (alternative) \n  \n  # phylogenetics\n  ###############\n  ggtree,           # visualization and annotation of trees\n  ape,              # analysis of phylogenetics and evolution\n  treeio            # to visualize phylogenetic files\n  \n)\n\n\n\nR-code & Packages\n\nmiltonfmr (quant-site)\nhttps://miltonfmr.com/complete-list-of-libraries-packages-and-resources-for-quants/\n\nTime-series\nhttp://www.time-series.net/\nFound this when I serched for material regarding VAR. Think I first found this link:http://www.fsb.miamioh.edu/lij14/ and this time-series via that. It should be a lot of example and framework relatied things regarding R-code, finance, but also academic list and material…\nCode https://sites.google.com/view/davidgabauer/econometric-code\nGithub: https://github.com/GabauerDavid/ConnectednessApproach\nR-workbooks: https://sites.google.com/view/davidgabauer/use-rpython\nNotes: I have testet some of the source files and scripts, and it looks very nice! I finally have found a script that cointains functions and setups necesssary for forcasting matrix`s over differant time-periods. I have stored the files on my mac-PC. ConnectednessApproach-master & firefox_files & dy2012_copi are foldes containing source code on my desktop.\n\nropensci\nhttps://ropensci.org\nData, software & reproducibility\n\nPackages, functions & librarys available in R\n\nHere I will store packages I personally find usefull. These packages will in general relate to datasience, finance and time seres modelling. But also r-markdown and reproducable reaserch document packages.\nMaterial\n\nR-Markdown & Reproducable Reasearch\nUlyngs (oxford template)\n-   <https://github.com/ulyngs/oxforddown>\nNTNU Latex og stil\nhttps://github.com/COPCSE-NTNU/master-theses-NTNU/tree/master/ntnuthesis\nhttps://www.math.ntnu.no/emner/TMA4268/2018v/1Intro/\n\nrstudioapi\nhttps://cran.r-project.org/web/packages/rstudioapi/rstudioapi.pdf\nbrukes feks til theme edit\n\nformatr\nhttps://yihui.org/formatr/#2-reformat-r-code\n\nBookdown\nhttps://bookdown.org/\nhttps://www.r-bloggers.com/2018/08/how-to-self-publish-a-book-customizing-bookdown/\nhttps://bookdown.org/ (alle bøkene)\n\n\nRiffomonasProject\nYoutube-Bruker: RiffomonasProject https://www.youtube.com/c/RiffomonasProject\n\n\nData Wrangeling\ntidyverse (General Package for Data Sience)\nbook: https://r4ds.had.co.nz/\ndplyr\nreadr\nlubridate (time, dateobject)\nOverview of packages https://www.tidyverse.org/packages/\n\n\nNickCHK\nYoutube-Bruker: NickCHK\n\nR-Hubs: https://rpubs.com/NickCHK/\n\n\nStatistical/Econometric models\n(empirical oriented)\nMTS (VAR framework)\nTsay, R. S\nhttps://github.com/d-/MTS/blob/master/R/MTS.R\nbook: Tsay, R. S. (2014). An Introduction to Analysis of Financial Data with R. John Wiley & Sons.\nTsay, R. S. (2013). Multivariate Time Series Analysis: With R and Financial Applications. John Wiley & Sons.\n\nNTS (Nonlinear Time Series Analysis)\nTsay, R. S\nhttps://faculty.chicagobooth.edu/ruey-s-tsay/research/nonlinear-time-series-analysis\n\nProf. Daniel P. Palomar (VAR/ARMA Vingette)\nhttps://palomar.home.ece.ust.hk/MAFS6010R_lectures/Rsession_time_series_modeling.html\nhttps://cran.r-project.org/web/packages/portfolioBacktest/vignettes/PortfolioBacktest.html\n\nFinance, Risk, Timeseries, Optimization functions\nFinance View Cran\nAll finance-related packages on R (CRAN). Amazing.\nhttps://cran.r-project.org/web/views/Finance.html\n\nintrocompfinr\nLink Introcompfin\n\nRmetrics (Framwork, several packages published)\nPDF-book Portfolio Optim: https://www.rmetrics.org/downloads/9783906041018-fPortfolio.pdf\nRmetrics fPortfolio vignette(GOOD) part 1 & 2:\nP1: https://miltonfmr.com/the-complete-guide-to-portfolio-optimization-in-r-part1/#rollstats\nP2: https://miltonfmr.com/the-complete-guide-to-portfolio-optimization-in-r-part2/\n\n\ntidyquant (Finance)\nlink: https://business-science.github.io/tidyquant/\n\nBLCOP (Black-Litterman model framework)\nlink: https://cran.r-project.org/web/packages/BLCOP/vignettes/BLCOP.html\ninstall: install.packages(“BLCOP”, repos=“http://R-Forge.R-project.org”)\nFound via: https://r-forge.r-project.org/R/?group_id=156\n\nQRMtools(general functions finance)\nI found this on youtube sometime when I studied for my exams. I have stored the link ever since, very nice and powerful tools and knowledge sharing!\nhttps://cran.r-project.org/web/packages/qrmtools/vignettes/geometric_risk_measures.html\nhttps://www.qrmtutorial.org/r-code?fbclid=IwAR1Qnkkq9d_Gt28-ptQmTmLpbIcGNwMudKxYyKFONKgkfWoa8X8p1HIXLg4 \n\nFRAPO\nhttps://www.pfaffikus.de/books/jwex2/\nhttps://www.pfaffikus.de/\n\nBlogroll: Finance & R-code\nFound this link via rgarch packages site on CRAN: http://www.unstarched.net/ via this link I found this link http://www.unstarched.net/blog/ and violah: I came here https://www.portfolioprobe.com/2012/01/05/the-top-7-portfolio-optimization-problems/ which gave me this blogroll https://www.thertrader.com/ with a nice vignette: https://www.thertrader.com/2017/06/04/linking-r-to-iqfeed-with-the-quanttools-package/\nThis is a good example of how quick, but also contentrich, the R-community, and especially for finance are!! There are so much interessting content, most likley written by the smartest/best people, availible for free! This happends all the time when I am searching around looking for packages, functions or methods I can use for my own project. I end up reading or studiung cases/ functions that is not actuelly what I am suposed to do… The only downside about R, is that you probebrly are going to burn out much of your planned work hours. So stay orginzed, but also; take some time enjoying what`s out there!! I am feeling blessed, really.\nBLOG-ROLL\nThe R Trader\nlink: https://www.thertrader.com/\nr-bloggers\nlink: https://www.r-bloggers.com/\ndatacamp.\nlink: https://learn.datacamp.com/\nGenerelle Notes\nIn this section I indtend writing down my own personal “studing” notes, and make space for chapters/parts for themes I find interessting writing notes aboout. These notes are written during a typical working sesh, or just another day I find it interessting searcing around the AMAZING community for datasience resoruces!\nMy notes could be anything within the category of datasience, modelling, finance and escpacially R. I want to gather my notes in one place(folder), in the hope of possible utizlizing a connection I suspect may excist between themes I learn about during my work sessions. Said in another way; You may find random themes and paragraphs here.\nFile types, how to store them and key differences\nIt dosent matter what kind of analyst you are trust me. R, Python, Java, C, C++, S or wathever; file-types and folderstructure is key if you want to master, or just even use code and programming-languages efficient. As a result of that, I indtend storing my own personal notes from studiong/resarching about filetypes I have often met when I have coded/worked on my own personal prosjects.\nI have felt both the frustration and the irritation of not understanding/taking enough time understanding what Its really all about. As a matter of fact, If you dont understand how the algoritm likes he`s food served.. you actuelly deserve beeing tortured by error messages. At least coused from not handling your files proper. It may sound wierd, but it could exist a kind of relashionship between algortims and humans in the sens of treting whats deare in the proper way. File and data is the maintance for the script!!!\nBelow I write down extention-names on filetypes I recollect on the go. If the [] box is emtpty, it means I have not started researching properly yet.\n\nCSV[x] XLS[x] zip[] gz[] tsv[] txt[]\n\nCSV -> stores the data as text. Can only store the values, not formatting and formulas etc. \nXLS -> stores data binary file. Readable for the computer. Can store values, formatting……\nMATERIAL FEEDER\nHere I will “feed” the block with links, notes, refs and material I explore. These need to be placed in the right sections. This part is then not included in the official “document” and will be removed when there`s eventuelly no more links to feed. I have placed this feed-block on the top of the document so I can easily see it, and start sortering when i begin a work section.\nfile:///C:/Users/lyder/Desktop/Bibliography-/Notes/bookmarks_7_15_21.html\nORGANISER DETTE!\n## Linker\nhttps://libraries.io/cran/RefManageR\n\nhttps://books.ropensci.org/drake/index.html\n\nhttps://www.youtube.com/watch?v=jU1Zv21GvT4&t=4055s\n\nhttps://www.rstudio.com/resources/rstudioglobal-2021/maintaining-the-house-the-tidyverse-built/\n  \nhttps://docutils.sourceforge.io/docs/ref/doctree.html#image\n\nhttps://books.ropensci.org/drake/index.html\n\n  \n  \n## PDF\nR-litteratur: mappe skrivebordet!!\n\nHar også sett på apperence_themes: shiny. \n\nIntro (START)\nThis document contains notes, links, referances and matarial I have used throughout the prosses.\n\n\n\n\nRefs to my own work stored some_where\nOutput github “test” https://github.com/lyder7/thesis-rasp/blob/master/r-markdown/test-html/test.md\nDenne har bilder, og formattering slik som html versjonen hadde. Fant denne linken via thesis-rasp\n\nResultater lagret i txt dokument https://github.com/lyder7/thesis-rasp/blob/master/r-markdown/test-html/resultater.txt\ntest.Rmd https://github.com/lyder7/thesis-rasp/blob/master/r-markdown/test-html/test.Rmd\ngenerelt lagret https://github.com/lyder7/thesis-rasp/tree/master/tekst\n\n\n",
    "preview": {},
    "last_modified": "2022-01-29T23:11:31+01:00",
    "input_file": {}
  }
]
