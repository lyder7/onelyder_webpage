[
  {
    "path": "posts/docker-input /",
    "title": "Docker - Linux Setup",
    "description": "Docker container config. Linux Kubuntu envir.",
    "author": [
      {
        "name": "Lyder Aleksander Mathisen",
        "url": "https://onelyder.com/posts/docker-input/"
      }
    ],
    "date": "2022-06-02",
    "categories": [],
    "contents": "\n\nContents\nDocker\nHvorfor Docker?\nHva jeg mener er viktig\n\nReferanser\nSession info\n\nDocker\nHvordan jeg kom i gang med Docker. Fra en bra skrevet\nvignette som tar for seg installasjonen via terminalen med Linux Ubuntu.\nResultatet er at Docker tilgjengelig, Jeg har laget en\nDocker Header bestående av en Ubuntu Distribusjon med\nnode.js konfigurert i Dockeren.\nArtikkelen jeg fulgte, install\nconfigure docker ubuntu, skrevet av linuxhint.com som også har andre\nbra artikler og veiledninger. Personlig foretrekker jeg ofte å lese\ndisse, enn å se Youtube videoer. [@hameed_how_nodate].\n\n\nlibrary(tidyverse)\nlibrary(fs)\nlibrary(here)\nlibrary(pacman)\npacman::p_load(reprex,\ntidyverse,\nfs,\nhere,\npacman)\n\n\n\nHvorfor Docker?\nDocker bringer noen spennende egenskaper som gjør\nmiljøet man programmerer i mer optimalt. Min anbefaling er å bruke\nartikkelen til å gjennomføre de første stegene i starten. I\nutgangspunktet rett frem og simpelt.\nHva jeg mener er viktig\nNår du har lastet ned Docker, og den er tilgjengelig, er\ndet et par ting du kan gjøre.\n\n\nsudo systemctl status docker\n\nsudo usermod -aG docker ${USER}\nsudo usermod -aG docker {$USER} # fish\n\nHer viser jeg hvordan du kan få nyttig info om hvordan du skal bruke\nDocker. Det holder å skrive bare Docker i\nterminalen, men jeg har under skrevet den fullstendige.\n\n\ndocker COMMAND --help\n\nViktig presisering: Etter man har lastet ned\nDocker og skal bruke det fremover, du må logge inn som\nadmin i systemet ditt.\nDu må være/bli en Sudu. Du kan enkelt gjøre det med\nsu - {\\$USER} eller su - \\${USER} avhengig om\ndu bruker fish eller ikke som shell.\nDa vil kommandoer som dette fungere:\n\nducker search ubuntu\n\nDet Docker gjør i koden ovenfor er å søke etter\ntilgjengelige Hubs som inneholder “ubuntu”. Dette kan videre brukes til\nå søke etter andre ting også. Eksempelvis kan du skrive\ndocker search r-studio og få en output med informasjon om\nhvilke som er tilgjengelig. Outputen i terminalen har en struktur hvor\ndet er 5 kolonner;\nNAME DESCRIPTION STARS OFFICIAL AUTOMATED\nReferanser\nSession info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ─────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.0 (2022-04-22)\n os       Linux Mint 20.3\n system   x86_64, linux-gnu\n ui       X11\n language en_US\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Oslo\n date     2022-06-02\n pandoc   2.17.1.1 @ /usr/lib/rstudio/bin/quarto/bin/ (via rmarkdown)\n\n─ Packages ─────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n assertthat    0.2.1   2019-03-21 [1] CRAN (R 4.2.0)\n backports     1.4.1   2021-12-13 [1] CRAN (R 4.2.0)\n broom         0.8.0   2022-04-13 [1] CRAN (R 4.2.0)\n bslib         0.3.1   2021-10-06 [1] CRAN (R 4.2.0)\n cachem        1.0.6   2021-08-19 [1] CRAN (R 4.2.0)\n cellranger    1.1.0   2016-07-27 [1] CRAN (R 4.2.0)\n cli           3.3.0   2022-04-25 [1] CRAN (R 4.2.0)\n colorspace    2.0-3   2022-02-21 [1] CRAN (R 4.2.0)\n crayon        1.5.1   2022-03-26 [1] CRAN (R 4.2.0)\n DBI           1.1.2   2021-12-20 [1] CRAN (R 4.2.0)\n dbplyr        2.1.1   2021-04-06 [1] CRAN (R 4.2.0)\n digest        0.6.29  2021-12-01 [1] CRAN (R 4.2.0)\n distill       1.4     2022-05-12 [1] CRAN (R 4.2.0)\n downlit       0.4.0   2021-10-29 [1] CRAN (R 4.2.0)\n dplyr       * 1.0.9   2022-04-28 [1] CRAN (R 4.2.0)\n ellipsis      0.3.2   2021-04-29 [1] CRAN (R 4.2.0)\n evaluate      0.15    2022-02-18 [1] CRAN (R 4.2.0)\n fansi         1.0.3   2022-03-24 [1] CRAN (R 4.2.0)\n fastmap       1.1.0   2021-01-25 [1] CRAN (R 4.2.0)\n forcats     * 0.5.1   2021-01-27 [1] CRAN (R 4.2.0)\n fs          * 1.5.2   2021-12-08 [1] CRAN (R 4.2.0)\n generics      0.1.2   2022-01-31 [1] CRAN (R 4.2.0)\n ggplot2     * 3.3.6   2022-05-03 [1] CRAN (R 4.2.0)\n glue          1.6.2   2022-02-24 [1] CRAN (R 4.2.0)\n gtable        0.3.0   2019-03-25 [1] CRAN (R 4.2.0)\n haven         2.5.0   2022-04-15 [1] CRAN (R 4.2.0)\n here        * 1.0.1   2020-12-13 [1] CRAN (R 4.2.0)\n hms           1.1.1   2021-09-26 [1] CRAN (R 4.2.0)\n htmltools     0.5.2   2021-08-25 [1] CRAN (R 4.2.0)\n httr          1.4.2   2020-07-20 [1] CRAN (R 4.2.0)\n jquerylib     0.1.4   2021-04-26 [1] CRAN (R 4.2.0)\n jsonlite      1.8.0   2022-02-22 [1] CRAN (R 4.2.0)\n knitr         1.39    2022-04-26 [1] CRAN (R 4.2.0)\n lifecycle     1.0.1   2021-09-24 [1] CRAN (R 4.2.0)\n lubridate     1.8.0   2021-10-07 [1] CRAN (R 4.2.0)\n magrittr      2.0.3   2022-03-30 [1] CRAN (R 4.2.0)\n memoise       2.0.1   2021-11-26 [1] CRAN (R 4.2.0)\n modelr        0.1.8   2020-05-19 [1] CRAN (R 4.2.0)\n munsell       0.5.0   2018-06-12 [1] CRAN (R 4.2.0)\n pacman      * 0.5.1   2019-03-11 [1] CRAN (R 4.2.0)\n pillar        1.7.0   2022-02-01 [1] CRAN (R 4.2.0)\n pkgconfig     2.0.3   2019-09-22 [1] CRAN (R 4.2.0)\n purrr       * 0.3.4   2020-04-17 [1] CRAN (R 4.2.0)\n R6            2.5.1   2021-08-19 [1] CRAN (R 4.2.0)\n readr       * 2.1.2   2022-01-30 [1] CRAN (R 4.2.0)\n readxl        1.4.0   2022-03-28 [1] CRAN (R 4.2.0)\n reprex      * 2.0.1   2021-08-05 [1] CRAN (R 4.2.0)\n rlang         1.0.2   2022-03-04 [1] CRAN (R 4.2.0)\n rmarkdown     2.14.1  2022-05-04 [1] Github (rstudio/rmarkdown@84dfc66)\n rprojroot     2.0.3   2022-04-02 [1] CRAN (R 4.2.0)\n rstudioapi    0.13    2020-11-12 [1] CRAN (R 4.2.0)\n rvest         1.0.2   2021-10-16 [1] CRAN (R 4.2.0)\n sass          0.4.1   2022-03-23 [1] CRAN (R 4.2.0)\n scales        1.2.0   2022-04-13 [1] CRAN (R 4.2.0)\n sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.2.0)\n stringi       1.7.6   2021-11-29 [1] CRAN (R 4.2.0)\n stringr     * 1.4.0   2019-02-10 [1] CRAN (R 4.2.0)\n tibble      * 3.1.7   2022-05-03 [1] CRAN (R 4.2.0)\n tidyr       * 1.2.0   2022-02-01 [1] CRAN (R 4.2.0)\n tidyselect    1.1.2   2022-02-21 [1] CRAN (R 4.2.0)\n tidyverse   * 1.3.1   2021-04-15 [1] CRAN (R 4.2.0)\n tzdb          0.3.0   2022-03-28 [1] CRAN (R 4.2.0)\n utf8          1.2.2   2021-07-24 [1] CRAN (R 4.2.0)\n vctrs         0.4.1   2022-04-13 [1] CRAN (R 4.2.0)\n withr         2.5.0   2022-03-03 [1] CRAN (R 4.2.0)\n xfun          0.31    2022-05-10 [1] CRAN (R 4.2.0)\n xml2          1.3.3   2021-11-30 [1] CRAN (R 4.2.0)\n yaml          2.3.5   2022-02-21 [1] CRAN (R 4.2.0)\n\n [1] /home/lyder/R/x86_64-pc-linux-gnu-library/4.2\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n────────────────────────────────────────────────────────────────────\n\n\n\n\n\n",
    "preview": {},
    "last_modified": "2022-06-02T04:44:43+02:00",
    "input_file": {}
  },
  {
    "path": "posts/function-review/",
    "title": "Function review 01",
    "description": "Deler noen funksjoner jeg har laget.",
    "author": [
      {
        "name": "onelyder",
        "url": "https://onelyder.com"
      }
    ],
    "date": "2022-06-02",
    "categories": [],
    "contents": "\n\nContents\n\n\n\n\n—> STATUS: NB! Fortsatt under utvikling.\nInnholdet er ikke klargjort. Anbefales ikke å leses da det kan være\npotensielle feil.. https://onelyder.com.\n\n\nInnledning\nPlukket ut det “beste” av kode jeg har skrevet i tidligere\nprosjekter. Skrevet om litt for å standardisere. Formålet med å\nstandardisere koden er for å kunne bruke den til flere scenarioer.\nDeler noen her:\nrelaxHead\nFunksjonen er laget for dokument- tekst produksjon. Spesifikt er\noppgave å lage tittel/ overskrifter. Mer spesifikt, foreløpig lager den\ntittelen hvor hvert ord i settingen har stor bokstav. Referanser er\nWickham (n.d.) og\nWickham and\nGarrett (2017, 2017; Wickham\nn.d.).\n\n\n# ------------------------------------------------------\n#\n# Author: Lyder Aleksander Mathisen \n# Date: \"06/01/2022\n# `relaxHead()` source code original\n# \n# github: github.com/lyder7\n# \n# ------------------------------------------------------\n# --------> Start with listing up the packages this program needs in a vestor c() called \"packages\":\npackages <- c(\"stringr\", \"pacman\", \"magrittr\")\n# sjekker om bibliotekene er installert og tilgjenglige. \n# Hvis noen av elemente i vektoren \"packages\" returnerer FALSE, installeres biblioteket lokalt i miljøet. Dersom teste returnerer TRUE lastes den ikke ned på nytt.  \ninstalled_packages <- packages %in% rownames(installed.packages())\nif (any(installed_packages == FALSE))\n{\n  install.packages(packages[!installed_packages])\n}\n\n\ninvisible(lapply(packages, library, character.only = TRUE))\n\n\n#------------------------------------------\n\n\n# -----> Function defines here:\n  relaxHead <- function(.x = \"...\") {\n    title <- as.character(.x)\n    low <- stringr::str_to_title(stringr::str_c(title))\n    assign(x = make.names(\"out\"),\n           value = low,\n           envir = .GlobalEnv)\n    return(out)\n  }     \n#-------------------------------------\n# ------> Test the function here: \nrelaxHead(\"dette SkAL bLi en fIN tiTTel\") %>% \n  print()\n\n\n#> [1] \"Dette Skal Bli En Fin Tittel\"\n\n\n#--------------------------------------\n\n\n\nno name yet biblotekar\nLast inn mange bibliotek raskt.\n\n\npackages <- c(\"pacman\")\n# checks if the package name is isntalled, if not it will be. ANd opsite. \ninstalled_packages <- packages %in% rownames(installed.packages())\nif (any(installed_packages == FALSE))\n{\n  install.packages(packages[!installed_packages])\n}\n\n\ninvisible(lapply(packages, library, character.only = TRUE))\n\n\npacman::p_load(\n  rio,\n  openxlsx,\n  tidyxl,\n  here,        \n  purrr,\n  rlang,\n  plyr,\n  tidyselect,\n  tidyverse,\n  skimr,\n  lubridate,\n  dplyr,\n  readxl,\n  janitor,\n  fs,\n  distill,\n  postcards,\n  rmarkdown,\n  bookdown\n)\n\n\n\n\n\n\nWickham, Hadley. n.d. “Introduction to Stringr.” Accessed\nJune 1, 2022. https://stringr.tidyverse.org/articles/stringr.html.\n\n\nWickham, Hadley, and Grolemund Garrett. 2017. R for Data\nScience. O’Reilly. https://r4ds.had.co.nz/.\n\n\n\n\n",
    "preview": {},
    "last_modified": "2022-06-02T01:03:45+02:00",
    "input_file": {}
  },
  {
    "path": "posts/power-bi-r/",
    "title": "Power BI i R",
    "description": "Hvilke muligheter åpner seg når R kode blir en del av Power BI? Dette dokumentet har som formål å undersøke hvordan powerbi oppgaver løses med R.",
    "author": [
      {
        "name": "onelyder",
        "url": "https://onelyder.com"
      }
    ],
    "date": "2022-05-27",
    "categories": [],
    "contents": "\n\nContents\n\n\n\n\nLyder Aleksander. This post status: is currently a\ndumping ground for ideas, and we don’t recommend reading it. https://onelyder.com.\n\n\nInnledning\nTil å starte med laster jeg inn noen standard pakker jeg trenger for\nå generere rapporten i sin helhet. Alt fra hvordan rapporten skal se ut,\ntil spesfikke funksjoner som brukes til f.eks analyse. Dette er fint å\ngjøre i starten av dokumentet, så de blir aktivert og er tilgjenglig\ngjennom genereringsfasen.\n\n\npacman::p_load(knitr, bibtex, tidyverse, pbixr, ggplot2, fs)\nknitr::opts_chunk$set(echo = TRUE)\n\n\n\nKoden ovenfor viser hvordan man enkelt kan sette rammene for økta.\nOfte klarerer man her generelle strukturer her, som ofte vil være likt\neller konstant. Spesfikke tilpassninger kan alikevell gjøre underveis,\nmen da er det bedre å gjøre disse for dem det faktrisk gjelder. Derfor\nstarter vi som her med det generelle.\nR pakker som kan brukes\nmed Power BI\nI skrivende stund er dagens versjon av R og R-studio 4.1.0. For å\nvise relevante delatjer kan jeg bruke R kode til å printe ut informasjon\nom miljøet jeg skriver i fra. “Learn Which R Packages Are\nSupported - Power BI” (n.d.) er\nmicrosoft sine egne sider med oversikt over hvilke pakker, samt hvilken\nversjon som kan brukes med Power BI (“Learn Which R Packages Are\nSupported - Power BI”\nn.d.).@r-powerbi blallb (“Pbixr: Access Data\nand Metadata from ’Microsoft’\n’Power BI’ Documents”\n2020).\n\n\nsuppressMessages(library(knitr))\nsuppressMessages(library(tidyverse))\n\na <- sessioninfo::session_info() \n\nprint(a$platform) %>% \n  data.frame %>% \n  kable()\n\n\n#>  setting  value\n#>  version  R version 4.2.0 (2022-04-22)\n#>  os       Linux Mint 20.3\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language en_US\n#>  collate  en_US.UTF-8\n#>  ctype    en_US.UTF-8\n#>  tz       Europe/Oslo\n#>  date     2022-05-27\n#>  pandoc   2.17.1.1 @ /usr/lib/rstudio/bin/quarto/bin/ (via rmarkdown)\n|| || || ||\n\nCRAN\nEn av de åpenbare svakhetene er at det stilles ganske strenge krav\ntil hva som er lov å bruke. Dersom noe avviker fra listen jeg\npresenterte kort ovenfor avviker, vil ikke analysen kunne gjennomføres.\nOfte er det relativt “gamle versjoner” av pakkene som kan brukes, som\nhar flere nye versjoner. Du kan se alle pakker, og tilhørende versjoner\npå (CRAN?) nettside (CRAN?).\nDet jeg reagerer mest på er at mange av de viktigste pakkene\nR-miljøet har utviklet de siste årene ikke er med, eller redusert\nkraftig. Tidyverse med sine tilhørende dplyr, tidyr osv er enten ikke\nmed, eller har gamle versjoner som mangler kritiske oppdateringer.\nNettopp disse utviklingen og tidyverse generelt har vært med på å lage\nen struktur, og et felles rammeverk for data analyse (tidyverse?).\nTidyverse\nTidyverse\n1.2.1 Info-Link\nDplyr\nversjoner liste\nFor å ta et eksempel tenkte jeg å vise hvordan man kan gå frem. Dplyr\ner en av de viktigste pakkene for data manipulering og analyse, så tar\nfor meg den i eksempelet. Prosessen vil være lik for andre pakker\nogså.\n\n\n\n#https://cran.r-project.org/src/contrib/Archive/ggplot2/ggplot2_3.2.0.tar.gz\n#https://cran.r-project.org/src/contrib/Archive/magrittr/magrittr_1.5.tar.gz\n#https://cran.r-project.org/src/contrib/Archive/PerformanceAnalytics/PerformanceAnalytics_1.5.2.tar.gz\n#https://cran.r-project.org/src/contrib/Archive/purrr/purrr_0.2.4.tar.gz\n#https://cran.r-project.org/src/contrib/Archive/readxl/readxl_1.0.0.tar.gz\n#https://cran.r-project.org/src/contrib/Archive/readr/readr_1.1.1.tar.gz\n#https://cran.r-project.org/src/contrib/Archive/rmarkdown/rmarkdown_1.9.tar.gz\n#https://cran.r-project.org/src/contrib/Archive/tidyverse/tidyverse_1.2.1.tar.gz\n\nurl <- \"https://cran.r-project.org/src/contrib/Archive/dplyr/dplyr_0.8.0.1.tar.gz\"\n\ninstall.packages(dplyr, url)\n\n\n\n\nI praksis\nEksempel\nR script i PowerBI\nReferanser\n\n\n\n“Learn Which R Packages Are Supported -\nPower BI.” n.d. Accessed October 22,\n2021. https://docs.microsoft.com/en-us/power-bi/connect-data/service-r-packages-support.\n\n\n“Pbixr: Access Data and\nMetadata from ’Microsoft’ ’Power\nBI’ Documents.” 2020. https://CRAN.R-project.org/package=pbixr.\n\n\n\n\n",
    "preview": {},
    "last_modified": "2022-05-27T01:33:34+02:00",
    "input_file": {}
  },
  {
    "path": "posts/git_devlab/",
    "title": "Git & Github: Branching",
    "description": "Bash scripting and commands.",
    "author": [
      {
        "name": "Lyder Aleksander Mathisen",
        "url": "https://onelyder.com/about"
      }
    ],
    "date": "2022-05-25",
    "categories": [],
    "contents": "\ngit kommandoer\nTerminal kommando for git. Under er nyttig kommandoer i\nforbindelse med branching av et prosjekt. Det vil si at det\ner en developer gren (branch) som parallelt med main (hoved)\ngrenen av prosjektet foretar endringer til nye tilskudd/endringer.\n\n# Lager ny branch \ngit branch from_startC dfed6bbc35053063a9b999d08170bb7b8c124504\n# Åpne branch \ngit checkout from_startC \n# print ut hvilken bracnh\ngit symbolic-ref HEAD\ngit add .\ngit commit -m \"commit text\"\n# Push til branchen \ngit push --set-upstream origin from_startC\n\n\n# Oversikt over commits\ngit log --graph \n#avslutt log modus \nshift + Q\n\n\n\n\n",
    "preview": {},
    "last_modified": "2022-05-25T19:18:17+02:00",
    "input_file": {}
  },
  {
    "path": "posts/loops-purrr/",
    "title": "R programmering",
    "description": "Purrr::map(). Last Updated: 2022-06-02 04:39:07",
    "author": [
      {
        "name": "Lyder Aleksander Mathisen",
        "url": "https://onelyder.com/posts/loops-in-r/"
      }
    ],
    "date": "2021-11-24",
    "categories": [],
    "contents": "\n\nContents\nFunksjoner i R\nOversikt\nover sentrale tidyverse pakker. Kartlegge bruksområder.\nBasis: Vektorer &\nstrukturer i R\nBasis: String\nfunksjoner sentrale\n\nTopics\nViktige basis konsepter\nSymboler\nLoops\npurrr::map\npurrr::map:\nforskjeller\n\n\nFunksjonell programmering i\nR\nTidyverse\nOppsett\n\nPurrr\nmap\nimap, pmap\nFunksjoner jeg har laget\nselv\n\nSideeffetcs\nEgne funksjoner\nLage\n\nrlang\nNoen tips\n\nC++ og R?\nNest\n\n\nAppendix\nRefernaser\n\nFunksjoner i R\n\n\nLyder Aleksander - Varsling: Under arbeid. Denne\nversjonen er ufullstendig og under utvikling. Denne versjonen kan\npotensielt inneha feil. Anbefales å ikke referere til denne utgaven av\ndokumentet.. https://onelyder.com/blog.\n\n\nOversikt\nover sentrale tidyverse pakker. Kartlegge bruksområder.\nBasis: Vektorer & strukturer\ni R\nKonsepter du må forstå eller akseptere for å beherske funksjoner,\nloops og representative operasjoner med R kode.\nUansett hvor kompleks en funksjon eller script fremstår,\nvil det i bunn og grunn bestå av mange sekvenser av relativt simple og\n“enkle” argumenter og funksjoner fra basisen. De absolutt viktigste og\nmest kritiske tar vi for oss nå.\nLær dem!\njennybc.github.io/purrr-tutorial\nVektor\nSamme klasse, en eller flere.\nData.frame\nSamling av flere vektorer, som vi kaller kollonner, bestående av\nsamme eller ulike type klasser i hver vetkor/kolonne.\nListe\nFlere eller samme klasse i vektorene, kompleks.\nBasis: String funksjoner\nsentrale1\nPrinte feks navnet til en funksjon, operasjon eller indeks som\nreferanse. Type output paste og past0. 2\npaste()\npaste0()\nTopics\nBasis Konsepter\nViktige basis konsepter\nSymboler\nLogiske sjekk-punkter\nViktige basis konsepter\ntidyverse og med alle data science verktøyene til R\nbrukere, er det allikevel etter min mening viktig å lære de fundamentale\nrammene. “base R” (Wickham and Grolemund\n2016; “Tidyverse” n.d.).\nFlere standard-pakker . utils, stats,\nmethods, grDevices, graphics og\ndatasets.\nFra R-studio kan man få en oversikt over pakkene, og se\nhva dem inneholder. Hvis man går til vinduet og klikker på menyen som\nheter “Enviroment”. Der vil det stå “Global Enviorment”. Trykk\npå rull-gardinen og det vil komme frem en oversikt over pakkene jeg\nnevnte over. Velg f.eks base.\nDet er mulig å redigere hvordan informasjonen vises. Helt til høyre i\nvinduet er det en ny rullegardin med en pil som peker ned, siden av\noppdater-symbolet. Grid og List er alternativene. Personlig foretrekker\njeg den første, fordi den viser informasjon over flere kolonner.\nFra oversikten kan du undersøke hvilke funksjoner som er\ntilgjengelig. Man kan også se kilde-koden. Muligheten til å se hvordan\nfunksjonene er bygget, nyttig når man utvikler ferdighetene innenfor\nprogrammering. Kilde koden gir muligens svaret man trenger for å\nkonkretisere eller gi en klar definisjon på hvordan funksjoner\nfungerer.\nLink\nBase R\nInne i R-studio, finn library. Åpne funksjonen.\nDet gir et perspektiv om hva som ligger bak funksjonene som brukes\nregelmessig.\nSymboler\nNotasjoner & symboler nyttig å lære. Bruken av disse kan\npotensielt gjøre funksjonene du skriver enda mer dynamiske og sterke.\nHer er noen av de symbolene jeg personlig ønsker å lære mer om:\ndo.call(function_name, object_name)\n%>% –> margitrrr.\nKjede-operator.\n%in%\n\\n\n\\t\n[[ ]] –> vektor\n[ ] –> list\nLogiske sjekk-punkter\nifelse base\nif_else dplyr\nall() base. Kan brukes på flere\nmåter:\nalene all(logical0==)) if(all(0)) –> Hvis alle\nverdiene definert av funksjonene så skjer:\n\n\nobject_a = NULL\nobject_b = NULL\nif(all(object_a == object_b)){\nprint(\"the objects are the same\")\n} else {\n peint(\"they are not true\")\n}\n\n\n#> [1] \"the objects are the same\"\n\nNB!! Husk at vi kan “tweake” funksjonen slik:\n\n\nobject_a = NULL\nobject_b = NULL\nif(!all(object_a == object_b)){\nprint(\"hello worlt\")\n} else {\n print(\"statemant not true\")\n}\n\n\n#> [1] \"statemant not true\"\n\nDet er også mulig å gjøre flere justeringer av funksjonen. Over skrev\nvi kun else, som vil si at hvis if-statementen\nførst resulterer i FALSE, så vil den gå over til neste\noppgave som er definert etter\nelse {\n}\nLiten endring:\nskriver else if () gjør vi slik at programmet vurderer\nen ny logisk test før den utfører en spesiell type oppgave. Dette er for\nå kontrollere funksjonens rute. Ofte er det nødvendig med av klaringer,\nog dersom noe avviker (som det testes for i if utsagnene)\nvil programmet rettet det opp.\nDette kalles kontrollflyt. Noen blokker viser else if\nvarianten:\n\nobject_a = NULL\nobject_b = NULL\n# 1\nif(all(object_a == object_b)){\nprint(\"the objects are the same\")\n} else if{\n print(\"they are not true\")\n}\nobject_a = NULL\nobject_b = TRUE\n# 2\n if(!all(object_a == object_b)){\nprint(\"hello worlf\")\n} else if( {\n print(\"statemant not true\")\n}\n\n**NB!!* * else må være på lik linje med den siste\nbrakken { for at R skal kunne evaluere den.\nLogic\ncheckpoints\nI utgangspunktet kan man fint bruke funksjoner som allerede finnes i\npakker. Som regel er de aller fleste pakkene innenfor ulike\nfagfelt/emner store i omfang, slik at de dekker de fleste verktøyene man\nvil trenge for en analyse f.eks.\nSannsynligheten for at et problem som ikke helt kan løses med pakken\ndu bruker, er funksjons bygging løsningen!\nKonseptet om at det er mulig å gi et objekt x\n<- \"hva_som_helst\". Altså, vi kan lagre\ntekst, tall eller funksjoner etc. inne i en sytstem-variabel vi kaller\nx. Det som gjør det kanskje enda mer forvirrende er at hvis\nvi lagrer variabelen som en funksjon, så kan den funksjonen i prinsippet\nbestå av hva som helst. Det er dette som gjør det fantastisk.\nLoops\nEksempel\npurrr\nEksempelet under viser et vanlig scenario hvor loops vil være\nnaturlig å bruke. Målet er å telle antall bokstaver i hvert navn i\nvektoren “names”.\nVidere følger vi god praksis ved å gjøre klar objektet resultatene skal\nlagres i. I dette tilfellet er det antall bokstaver i hvert navn.\n\n\nnavn <- c(\"Lyder\", \"Aleksander\", \"Mathisen\")\nn_ord <- vector(\"double\", length(navn)) # Expecting double\n\n\n\nVidere lager vi en loop som utfører operasjonen i en bolk. Årsaken\ntil at man bruker loops er fordi man ønsker å unngå reputasjon. Det er\nikke bra å gjenta seg selv. Derfor skriver man heller en loop som gjør\nalt vi ønsker i en bolk slik som under.\n\n\nfor(i in seq_along(navn)) {\n  n_ord[[i]] <- stringr::str_extract(navn[[i]], \"\\\\w\") # Returns character\n}\nn_ord\n\n\n\nFor hvert element i, i antall sekvenser i vektoren \\(`navn`\\), utfør funksjonen\nstr_extraxt() på objektet navn[]indeks\ni, lagre resultatet i objektet \\(`n_ord`\\) indeks \\(`i`\\).\nResultatet er altså: vi får et objekt n_ord bestående av antall\nbokstaver (resultatet) for hvert navn. I dette tilfellet er det 3 navn,\nsom bestyr 3 resultater.\npurrr::map\nEksemplet over viser hvordan loops kan utføres. Dette er den\ntradisjonelle måten å gjøre det på. Man kaller det ofte “basis R\nforloops”.\nKonseptet loops3 innenfor programmering generelt sett\ner et viktig og veletablert tema eller konsept. For språk som C, C# og\nC++ eller Python er loops spesielt “the way” og på mange måter\nen del av flyten i språket for de som bruker det som deres nummer1\nspråk.\nC++ er feks kjent som det aller raskeste og effektive språket. Særlig\nfor oppgaver hvor loops er nyttig. For R derimot er det spesielt for\nkritikere av R, et godt etablert sannhet at loops går tregt.\nSammenlignet med da feks C++.\nSå klart har det i realiteten ingenting å si for små prosjekter eller\nanalyser. Men satt i perspektiv; det er ikke effektivt å skrive loops i\nR.\nÅrsaken er kompleks og mer sammensatt til å forklare det enkelt og\nintuitivt. Men det har rot i hvordan syn-tak-strukturen i R er bygget\nopp, og antall linjer/bokstaver, samt objekter som er nødvendig å skrive\nfor å utføre funksjoner eller representative operasjoner.\nLøsningen på dette problemet er purrr fra\ntidyverse pakken for R.\npurrr er en pakke som tar for seg funksjonell programmering spesifikt\nmed R-kode. Pakken har utviklet konsepter og metoder som gjør at vi\nfaktisk kan utføre oppgaver og operasjoner hvor loops i utgangspunktet\nhadde vært en del av løsningen. Du kan betrakte det som en måte å gjøre\nloops på, uten å skrive loops. Merkelig nok..\nDet du isteden burde gjøre for å forstå dette konseptet er å tenkte\npå representative operasjoner som skal gjøres for alle elementene i\nobjektet. Altså at noe skal utføres flere ganger på flere ulike\nelementer innenfor et objekt vi undersøker/analyserer. 4\npurrr::map:\nforskjeller\ni in seq_along(object) erstattes med .x\nmap utfører loopen med hensyn til hva slags\nclass .x er.\nVektor, data.frame eller liste er derfor av\nbetydning!\n{ body }erstattes med .f\nfunksjonen eller oppgaven som skal utføres\nmap()er hovedfunksjonen.\nMen det er noen hjelpere for å garantere/kontrollere output:\nmap_dbl()\nmap_chr()\nmap_int()\nmap_dfr()\nwalk()\nFunksjonell programmering i\nR\nTidyverse\nPurrr er en pakke fra Tidyverse paradigme som hjelper til med\nfunksjonelle operasjoner. Ved bruk av tidy prinsippene hjelper\npurrr oss med å utføre operasjoner på en effektiv måte. Alternativet er\nå skrive egne funksjoner. Risikoen ved egne funksjoner er at outputen er\nkanskje riktig for den spesifikke settingen funksjonen lages. Men over\ntid og ved gjenbruk på andre data sett kan den gi resultater som\nmuligens er feil. I dette kapittelet er formålet å bli bedre kjent med\npurrr og se på scenarioer hvor purrr kan være et nyttig\nhjelpemiddel.\nOppsett\nTil å starte med laster vi inn tidyverse. Alternativ er det også\nmulig å laste inn purrr ved library(purrr).\n\n\nlibrary(tidyverse)\n\n\n\nVidere trenger vi et datasett som vi kan bruke underveis. I\ntidyverse pakken finnes et datasett som heter\niris. Dersom tidyverse er lastet inn er det mulig å referere\ntil datasettet. Det har vi allerede gjort, og av den grunn lagrer jeg\niris under navnet data_iris. Se kodesnipp under:\n\n\ndata_name <- iris %>% \n  as_tibble()\ndata_name \n\n\n#> # A tibble: 150 × 5\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#>          <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n#> 1          5.1         3.5          1.4         0.2 setosa \n#> 2          4.9         3            1.4         0.2 setosa \n#> 3          4.7         3.2          1.3         0.2 setosa \n#> 4          4.6         3.1          1.5         0.2 setosa \n#> 5          5           3.6          1.4         0.2 setosa \n#> 6          5.4         3.9          1.7         0.4 setosa \n#> # … with 144 more rows\n\nKoden over viser hvordan data-settet “iris” kan refereres til etter\nat tidyverse er lastet inn. Videre ser vi at iris blir lagret i en\nvariabel vi kaller data_name. I prinsippet kunne vi valgt å\n“døpe” datasettet til noe annet. Og til slutt ser vi at de 10 første\nradene i datasettet kommer frem når vi skiver data_name til\nkonsollen. Her er formålet å få et kjapt overblikk over hvordan datan\nser ut.\nPurrr\nmap\nFor å bli kjent med data er det fra base R vanlig å\nutføre funksjonen class(). Den gir tilbake informasjon om\nhvilke klasser datasettet består av. Dersom vi utfører\nclass(data_name) får vi som output\ndata.frame. Det er fordi class()\nfunksjonen kjøres på objektet data_name som\nhelhet. Noen ganger kan det være nyttig å få informasjon om hver\nvariabel, som blir det samme som hver kolonne i et data sett.\nEn løsning er å gjøre slik:\nclass(class(data_name$Sepal.Length)) eller\nclass(data_name[,1]). Ulempen med denne måten er at den er\ntreg og lite effektiv. For å sjekke neste kolonne må vi skrive\nclass(data_name[,2]) etc. helt frem til vi har testet alle\nvariablene vi er interessert i. I praksis vil det være alle kolonnene i\net datasett.\nMed purrr pakken kan vi sjekke alle kolonne med en funksjon og en\nlinje med kode. Tilbake gir den oss en vektor med resultatet fra alle\nvariablene/ kolonnene i datasettet som vi har lagret som\ndata_name. Se under:\n\n\nmap_chr(data_name, class)\n\n\n#> Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species \n#>    \"numeric\"    \"numeric\"    \"numeric\"    \"numeric\"     \"factor\"\n\nÅrsaken til at vi bruker map_chr er fordi konsollen blir\nfremvist i et objekt lagret som character\nclass. Til vanlig og som defoult lagres output fra\nmap() funksjoner i lister. Det vil si at vi kan gjøre\nakkurat det samme med denne syntaksen:\n\n\nmap(data_name, class)\n\n\n#> $Sepal.Length\n#> [1] \"numeric\"\n#> \n#> $Sepal.Width\n#> [1] \"numeric\"\n#> \n#> $Petal.Length\n#> [1] \"numeric\"\n#> \n#> $Petal.Width\n#> [1] \"numeric\"\n#> \n#> $Species\n#> [1] \"factor\"\n\nMen her får vi resultatet lagret i en liste. Lister er mer komplisert\nå jobbe med, og er generelt vanskeligere å referere til i etterkant.\nDerfor ønsker vi å gjøre det så enkelt som mulig, å dermed bruke\nmap_chr() som lagrer det for oss i en\ncharacter class.\nVi kan også lagre konsollen og referere til den i etterkant hvis vi\ntrenger det. Under gjør vi eksakt samme operasjon, utfører\nclass() funksjonen til alle variablene i datasettet\ndata_name. Vi lagrer resultatet i\ndata_name_classes. Videre bruker vi pipe fra\nmagrittr til å utføre funksjonen glimpse() som\ngir oss en oppsummering-tabell av innholdet. Se under:\n\n\ndata_name_classes <- map_chr(data_name, class)\ndata_name_classes %>% \n  glimpse()\n\n\n#>  Named chr [1:5] \"numeric\" \"numeric\" \"numeric\" \"numeric\" \"factor\"\n#>  - attr(*, \"names\")= chr [1:5] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" ...\n\nLogikken med map er at den tar inn noen viktige input i\nfunksjonen. Den etterspør .x og .f\n.x = en vektor funksjonen skal utføres på\n.f = valgt funksjon.\nVårt tilfelle er .x = data_name og\n.f = class .\nimap, pmap\nFunksjoner jeg har laget\nselv\nI denne delen tar jeg for meg egne funksjoner og skisser skrevet av\nmeg selv. Målet er å videre utvikle dem og sette de til verks.\n\n\n#Info om hvilken mappe data ligger i + navn p? sheets \npath <- \"data_raw/transaksjoner.xlsx\"\nsheets <- readxl::excel_sheets(path)\n## Alle sheets i excelark er data.frames\npurrr::walk(\n  .x = excel_sheets(path),\n  .f = function(x) {\n    new_nm <- tolower(x)\n    assign(new_nm, read_excel(path, sheet = x), envir = .GlobalEnv)\n  }\n)\n\n\n\nBryte ned til flere deler er nok lurt å gjøre.\n1 består av data inn. Det kan være et excel ark med flere sheets som er\naktuelt. Fra mitt eksempel kan det være regnskapsdata bestående av\nkolonner med tall, tekst og dato. Ofte er disse filene store for\nselskaper i en visse størrelser. Vi ønsker derfor å laste inn data slik\nat hver flik blir ett data.frame objekt i R, som kan brukes\nvidere.\n\n# nest kan være neste steg. HVer data.frame er ett element i samme liste. Bruke det til å refere til for en loop-opperasjon. \n# Her er hva jeg tenker vist med en for looop:\nfor(i in seq(walk_object)){\n  \n  df[[i]] <- walk_object[[i]]\n  \n  a <- df\n  \n  if(!class(df)){\n    \n    # Data formattering starter\n    a <- a %>% \n      \n      \n      # Data frame class\n      tidyr::as_tibble()\n    \n      if(is.na(NA) = TRUE){\n        \n        drop_na(a)\n      }\n    \n    else{\n      \n      \n      \n      \n      \n    }\n      return(a)\n    \n  }\n  # freq antall varaibler/kolonner\n  if(count_(names(a)) == freq){\n    \n      kolonne_nanv <- names(a)\n      \n      # Velg kolonner \n      select(all_of(kolonne_navn)) %>% \n        \n      arrange(desc(.x)) %>% \n      \n      ##lage kolonne med diff \n      mutate(endring_periodeV = (data2021 - data2020))\n  }\n      if(desc(.x)) {\n        drop_na(NA %==% .x) %>%\n          else {\n            return(navn_her)\n            \n          }\n          mutate()\n      }\n      \n      drop_na(NA %==% .x) %>% \n      \n      \n      ## Regnskapskontoer i SB\n      \n    mutate(str_glue(konto_navn) == filter(vroom::starts_with(kolonne_navn)))\n      \n  }\n}\n# Dette kan gjøres med purrr og tidyr \ntidyr::nest()\n\nNeste steg er å generalisere operasjonene som skal gjøres excel\narkene. Første spørsmål: er operasjonen lik for alle data-sett og\nalle kolonner?\npurrr erstatter loops laget selv\ndplyr for manipulering\nstringr for tekst\ntidyr for modellering, spesielt lister\nSideeffetcs\nWalk funksjonen til purrr er en variant som brukes når\nfunksjonen implementert har/ikke en output type som kalles\nsideeffekt. Output generelt kan beskrives i form av utsende;\ntabell, tall og annen tekst som er resultatet fra en operasjon utført\nvia en funksjon som i sum utfører en rekke betinget rekkefølge med\nkommandoer og andre underliggende funksjoner som skaper objekter eller\nresultater, som printes ut i sin form i konsollen. Det betyr at vi kan\nse hva resultatet er, i form av konsoll-tekst.\nMotsetningen er at vi har funksjoner som gir output uten side\neffekter. Her gjør funksjon operasjoner som er utenfor dens “scope”.\nEksempler er ploter eller genereringen av excel-sheets til en\nny arbeidsbok som lages i R.\nDisse resultatene, fra ikke siden-effekt funksjons typer er at man\nikke kan lagre resultatet i et objekt som kan refereres til i etterkant.\nOutput er til motsetning slik at den vises frem i konsollen i en mer\nfysisk form. Enten som en graf, plot.\nÅrsaken til at dette er viktig å få med seg, er fordi output og hva\nfunksjoner vi faktisk bruker, er utrolig viktig for å programmere\neffektivt.\nF.eks med funksjonen addWorksheet funksjonen, så gir den\ningenting av output. Den endrer noe “utenfor scopet”.\nEgne funksjoner\nI dette kapittelet tar vi et steg videre. Jeg vil forsøke å vise- og\nlære hvordan man kan lage sine helt egne funksjoner. I prinsippet er\nalle funksjoner mulig å lage. Funksjoner har en fast form som vi skal se\nnærmere på her. Hvis denne formen følges, er det som et utgangspunkt opp\ntil deg som forfatteren av funksjonen, hva den skal bestå av.\nI de første kapitalene var vi innom det grunnleggende konseptet hvor\nman ved bruk av <- eller = kan “lagre” data\ni objektet som vi selv velger hva skal hete. a <- 1 feks. Det vil si\nat a representerer tallet 1, og hver gang vi bruker a, vil det bli lest\nog tolket som 1.\nLage\nI utgangspunktet er det flere tusen funksjoner tilgjengelig som kan\nbrukes. Som regel vil man komme langt med disse. Men som regel er det\nnoen særtrekk med akkurat ditt problem, som funksjonen i pakken ikke\nevaluerer slik du ønsker. Det kan være flere grunner til det, men en\ntypisk årsak til å skrive egne funksjoner kontra bruke andre sine, er\nfor å tilpasse funksjonaliteten til problemet som du skal løse. Det er\nmest sans behov for noen tweaks og små justeringer. Men det kan også\nvære tilfellet hvor det ikke finnes noe fra før, så man skriver hele\nfunksjonen- og kanskje en hel pakke, for å løse problemet.\nJeg tar derfor først for meg standariserte funksjoner som er\nspesielle og egnet til å bruke i nye funksjoner også.\nrlang\nFor å gå litt dybere til verks for å forstå hva salgs hjelpemiddler\nog funksjoner som er i pakkene jeg personlig bruker til funksjoner og\nfunksjonell prgrammering i R. I kodesnippen under tar jeg å henter ut\nfunksjonsnavnene i pakken rlang, margitr, og purrr. Jeg lagrer disse i\net objekt, og sammenligner dem mot hverandre.\n\n\npac <- pacman::p_functions(package = \"rlang\") %>% \n  as_vector() \n \npur <- pacman::p_functions(package = \"purrr\") %>% \n  as_vector()\nmag <- pacman::p_functions(package = \"magrittr\") %>% \n  as_vector()\n\n\n\n\n\ndf <- cbind(pac, pur, mag) %>% \n  as_tibble() %>% \n  glimpse()\n\n\n#> Rows: 434\n#> Columns: 3\n#> $ pac <chr> \":=\", \"!!\", \"!!!\", \".data\", \".env\", \"%@%\", \"%@%<-\", \"%<~…\n#> $ pur <chr> \"%@%\", \"%>%\", \"%||%\", \"accumulate\", \"accumulate_right\", …\n#> $ mag <chr> \"%!>%\", \"%<>%\", \"%>%\", \"%$%\", \"%T>%\", \"add\", \"and\", \"deb…\n\nÅrsaken til denne sammenligningnen er for å indentifisere nyttige\nkontroll-funksjoner vi kan bruke når vi bygger opp våre egne. Logiske\nfunksjoner som er TRUE eller FALSE er et velkjent konsept for\nprogrammerere. Det brukes til å kontrollere flownen og det som skjer\ninne i {}.\nSom nevnt tidligere er R og andre språk avhengig av rekkefølgen på\nhvordan ting gjøres. Resultatet av noe, vil påvirke et objekt, som vil\nha konsekvenser for videre flyt. For å hindre at feil objekter, eller\ndata typer taes inn videre, gjør man derfor\nif statement.\nDet vil si at inne i funksjonen vil det være en egen if evaluering.\nDersom den logiske testen = TRUE vil den slippe inn i brakke t4egenne.\nDersom FALSE hopper den over denne delen.\n\n\nfunction(x){\n  if(is.character(x)){\n  \n  }\n  return(x)\n}\n\n\n\nSom kode snippen viser over, er det altså en egen seksjon som er\nbetinget av if testen.\nNoen tips\n\n\n# Lager en vektor med elemtener\nvector <- c(\"Lyder\", \"Aleksander\", \"Mathisen\")\n# Lønsing 1 \n\"Lyder\" %in% vector\n\n\n#> [1] TRUE\n\n#Løsning 2\nany(vector == \"Lyder\")\n\n\n#> [1] TRUE\n\nany(vector == \"Henrik\")\n\n\n#> [1] FALSE\n\nKode snippen viser et typisk scenario hvor vi ønsker å sjekke om en\nvector består av en spesifikk verdi. I tilfellet jeg skrev over laget\njeg bare en vektor bestående av navnet mitt. Det vil si det er tre\nseparate elementer i vektoren. Under, løsning 1, tester jeg om “Lyder”\ner i vektor. Svaret er TRUE. Men et tips er å bruke løsning 2. Den gjør\ndet samme, men er mer effektiv og standardisert. Det er derfor best\npractice å ta i bruk denne. Resultatet blir TRUE her også. Nederst tok\njeg med evaluering av et element som ikke er en del, bare for å vise at\ndenne resulterer FALSE.\nC++ og R?\nNoen spesifikke operasjoner er mer effektivt å gjøre med C++. R har\ngode løsninger som kobler språkene sammen, slik at det mest nødvendige\noppgavene kan kjøres i C++ program, men hvor det allikevel skrives i R\nstudio slik du er vant til. Pakken Rcppfikser dette for\noss. Under trekker jeg ut funksjoner:\n\n\nlibrary(Rcpp)\npacman::p_functions(package = \"Rcpp\")\n\n\n#>  [1] \".__C__C++Class\"             \".__C__C++Constructor\"      \n#>  [3] \".__C__C++Field\"             \".__C__C++Function\"         \n#>  [5] \".__C__C++Object\"            \".__C__C++OverloadedMethods\"\n#>  [7] \".__C__Module\"               \".__C__RcppClass\"           \n#>  [9] \".__T__.DollarNames:utils\"   \".__T__[:base\"              \n#> [11] \".__T__[[<-:base\"            \".__T__[<-:base\"            \n#> [13] \".__T__$:base\"               \".__T__$<-:base\"            \n#> [15] \".__T__formals<-:base\"       \".__T__initialize:methods\"  \n#> [17] \".__T__prompt:utils\"         \".__T__show:methods\"        \n#> [19] \".DollarNames\"               \"compileAttributes\"         \n#> [21] \"cpp_object_dummy\"           \"cpp_object_initializer\"    \n#> [23] \"cppFunction\"                \"demangle\"                  \n#> [25] \"evalCpp\"                    \"exposeClass\"               \n#> [27] \"formals<-\"                  \"getRcppVersion\"            \n#> [29] \"initialize\"                 \"LdFlags\"                   \n#> [31] \"loadModule\"                 \"loadRcppClass\"             \n#> [33] \"loadRcppModules\"            \"Module\"                    \n#> [35] \"populate\"                   \"prompt\"                    \n#> [37] \"Rcpp.package.skeleton\"      \"Rcpp.plugin.maker\"         \n#> [39] \"RcppLdFlags\"                \"registerPlugin\"            \n#> [41] \"setRcppClass\"               \"show\"                      \n#> [43] \"sizeof\"                     \"sourceCpp\"\n\nNest\ntidyr::nest()\nAppendix\nRefernaser\n\n\n\n“Tidyverse.” n.d. Accessed September 10, 2021. https://www.tidyverse.org/.\n\n\nWickham, Hadley, and Garrett Grolemund. 2016. R for Data Science:\nImport, Tidy, Transform, Visualize, and Model Data. \" O’Reilly\nMedia, Inc.\".\n\n\nBrukes inne i funksjoner gjennom å\nprinte feks navnet til en funksjon, opperasjon eller indeks som\nreferanse.↩︎\nString manipulator. Typiske oppgaver\nsom slå sammen to navn, separere ett ord til to ord, skille to ord med\nen valgt symbol “\\” etc. er eksempel på scenarioer disse brukes.↩︎\nloops, foreloops, whileloops,\nnestetloops etc.↩︎\nPrøv å unngå vrangforestillinger og\nmissforståelser rundt ordet “loops”. Tenk på det som noe vi skal utføre\nflere ganger på forskjellige enheter.↩︎\n",
    "preview": {},
    "last_modified": "2022-06-02T04:39:11+02:00",
    "input_file": {}
  },
  {
    "path": "posts/loops-r/",
    "title": "Loops i R",
    "description": "Purrr::map(). Last Updated: 2022-06-02 04:40:04",
    "author": [
      {
        "name": "Lyder Aleksander Mathisen",
        "url": "https://onelyder.com/posts/loops-in-r/"
      }
    ],
    "date": "2021-11-24",
    "categories": [],
    "contents": "\n\nContents\nFunksjonell programmering i R (?)\nNoen basis ting først\nProgrammering i R\nwalk og\nmap\nGenerelt om loops\nMap istedenfor loops\n\n\nReferanser\n\n\n\nLyder Aleksander - Varsling: Under arbeid. Denne\nversjonen er ufullstendig og under utvikling. Denne versjonen kan\npotensielt inneha feil. Anbefales å ikke referere til denne utgaven av\ndokumentet.. https://onelyder.com/blog.\n\n\nFunksjonell programmering i R (?)\nInspirert av Bruno Rodriguez sin video Don’t write\nloops in R.\nVidere har jeg fylt på med noen ideer og tanker jeg har om temaet.\nMen først laster jeg inn pakkene som trengs for å kjøre igjennom det jeg\nhar tenkt å vise frem. Kode-snippen under laster inn det som trengs,\nhvor spesielt tidyxl, openxlsx og\nreadxl har unike funksjoner tilpasset for Excel.\n\n\nlibrary(tidyverse)\nlibrary(tidyxl)\nlibrary(openxlsx)\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(readxl)\nlibrary(here)\n\n\n\nDe andre pakkene som purrr og dplyr er\nspesielt egnet for det funksjonelle operasjonene som skal foretas, etter\ndata-filene er lastet inn og formatert. Den siste pakken\nhere er alltid kjekk, fordi den hjelper til med å si ifra\ntil konsollen hvor arbeids mappen vår er, slik at vi kan bruke relative\nreferanser underveis. Altså ~/. Tidyverse gir\ntotalen, den laster inn alle pakkene, som består av totalt 30 pakker\nutviklet av Hadley Wickham. Se mer om\ntidyverse her\nNoen basis ting først\nNoen “basis” ting som er nyttig:\n\".\" —> betyr i “dette området”.\nAltså mappen PCen din befinner seg i. Arbeids mappen.\nHer ser dere et eksempel hvor jeg bruker en funksjon\nlist.files og bruker “.” som argument for hvilken path den\nskal lete i. I tillegg spesifiserer jeg hvilken filtype jeg ønsker å\nlete etter.\n\n\nlist.files(\".\", pattern = \".xlsx\")\n\n\n#> [1] \"demo_workbook.xlsx\"                          \n#> [2] \"top2000.xlsx\"                                \n#> [3] \"UK Labour Market - Sickness and Absence.xlsx\"\n#> [4] \"Uk Labour Productivity - Time Series.xlsx\"   \n#> [5] \"UK Public Service Productivity.xlsx\"\n\nMen jeg kunne også spesifisert at jeg vil lete i et spesifikt område\ni arbeidsmappen min. For eksempel hvis jeg har en mappe som heter “data”\nhvor jeg har alle data-filene mine inne i. For eksempel excel ark.\n\n\nlist_data <- list.files(\".\", pattern = \".xlsx\")\nlist_sheets <- paste0(\"sheet_\", seq(1, length(list_data)))\n\nmy_excel_workbook <- createWorkbook()\n\n\n\nProgrammering i R\nwalk og map\nHva er forskjellen mellom walk og map? Og\nnår skal man bruke dem?\nwalk gjør noe utenfor sitt scope –> ikke noe objekt\nsom blir lagret. Den gir altså ikke et objekt som man kan referer til\nsenere. Slik man feks kan gjøre dersom man skriver for eksempel a <-\n“objekt”. Etter å ha kjørt igjennom den kommandoen, vil “objekt” bli\nprintet ut i konsollen hvis jeg skriver bare a.\nSlik er det altså ikke med walk. Den utfører operasjoner\nsom resulterer i typiske outputs som vil vise noe. Ett plot eller som\nunder ett excel ark, som vi senere kan skrive ut som en\n.xlsxfil for eksmepel. Men før vi gjør noe med det, kan vi\nikke “se” det nødvendigvis.\n\n\n\nlist_sheets %>% \n  walk(~addWorksheet(my_excel_workbook, sheetName = .))\n\n\n\nDet er flere utgaver av denne funksjonen, som når det er 2 objekter\nvi trenger å utføre funksjonen med. Den kalles walk2, og er\nfra samme pakke purrr.\nwalk2 brukes når vi trenger ta inn flere objekter.\n\n\nwalk2(.x = list_sheets,\n      .y = list_data,\n      ~writeData(my_excel_workbook,\n                sheet = .x,\n                x = .y ))\n\n\n\nGenerelt om loops\nEt nytt eksempel er for å undersøke antall formler som finnes i et\nexcel dokument, eller dokumenter vi ønsker å jobbe med. Det kan være\njobb/skole relaterte Excel-filer.\n\n\nlist_xlsx <- list.files(\".\", pattern = \".xlsx\")\n\n\n\nFørst kan jeg sjekke en spesifikk Excel ark. Da spesifiserer i\nkommandoen under at det er fra list_xlsx[3] det er info jeg\nvil ha. Og list_xlsx[3] vil være det samme som navnet til\nExcel fila.\nDet som videre skjer er at vi tar i bruk noen nyttige funksjoner fra\ntidyxl pakken. xlsx_cells sammen med filter,\nog !i s.na gjør at denne kodenippen gir oss tilbake formler.\n\n\nxlsx_cells(list_xlsx[3]) %>%\n  filter(!is.na(formula)) %>% \n  head() %>% \n  pull(formula)\n\n\n#> character(0)\n\nOver ser dere hvile former som er aktuelle. Nå har jeg brukt head(),\nså da vises bare de første elementene. Men her får vi et eksempel på\nhvilke formler. I denne går det i VLOOKUP som dere ser\nover.\nNoe annet nyttig er å finne ut hvor mange formler det er snakk om.\nAltså hvor mange celler i Excel arket vi jobber med består av formler.\nKodesnippen under er bare en listen justering fra den forrige, ved at vi\nnå sier nrow() som gir antall rader.\n\n\nxlsx_cells(list_xlsx[3]) %>%\n  filter(!is.na(formula)) %>% \n nrow()\n\n\n#> [1] 0\n\nMen vi kan generalisere dette i en så kalt “fore loop”. Det betyr at\ni istedenfor å skrive inn hvilken vil vi ønsker, altså\nlist_xlsx[3].. osv, kan vi heller loope over alle og lagre\nsvarene i et objekt. Med andre ord, vi kan få resultatene fra alle\narkene i ett objekt, i en operasjon.\nNår man skal lage loops på den klassiske måten, er det\nviktig å først huske å lage et objekt som vi kan lagre resultatene\ni. Her lager jeg objektet results som er en numerisk\nvektor bestående av 0, og har samme lenge som objektet vi tar inn\nlist_xlsx. Som forøvrig i dette tilfellet er 7. Altså 7\nfilnavn.\n\n\nresults <- rep(0, length(list_xlsx))\n\n\nfor(i in seq_along(list_xlsx)){\n  results[i] <- xlsx_cells(list_xlsx[i]) %>%\n    filter(!is.na(formula)) %>% \n    nrow()\n}\nprint(results)\n\n\n#> [1] 0 0 0 0 0\n\nLoopen gjør det samme for alle xlsx filene. Den sjekker hvor mange\nceller er det som inneholder formler. Svarene lagres i results objektet.\nOg resultatet er at vi nå vet at det er \\[3\\] som har 2159, dem andre har ingen.\nMen vi vil også kanskje vite navnet på filene. Det kan vi fikse. Vi\nmå bare gjøre en liten justering, trikse og mikse litt. Se under\n\n\nresults <- cbind(rep(0, length(list_xlsx)), 0)\n\nfor(i in seq_along(list_xlsx)){\n  results[i, 1] <- list_xlsx[i]\n  results[i, 2] <- xlsx_cells(list_xlsx[i]) %>%\n    filter(!is.na(formula)) %>% \n    nrow()\n}\n\nresults\n\n\n#>      [,1]                                           [,2]\n#> [1,] \"demo_workbook.xlsx\"                           \"0\" \n#> [2,] \"top2000.xlsx\"                                 \"0\" \n#> [3,] \"UK Labour Market - Sickness and Absence.xlsx\" \"0\" \n#> [4,] \"Uk Labour Productivity - Time Series.xlsx\"    \"0\" \n#> [5,] \"UK Public Service Productivity.xlsx\"          \"0\"\n\nNå fikk jeg et svar som består av 2 kolonner. Nå vet jeg hvilken\nExcel fil det gjelder, og jeg vet også hvor mange formler det er i den\ngitte filen.\nVidere kan man justere dette enda mer for å gjøre det mer\noversiktigling og ordentlig. Her konverterer jeg bare svarene vi fikk om\ntil en data.frame, fordi det opprinnelig var en matrix.\nVidere tar jeg bare å bruker funksjonen rename for å endre\nkolonnenavn. Det er akkurat samme svar, bare presentert på en annen\nmåte. Mer ryddig og ordentlig.\n\n\ndata.frame(results) %>% \n  rename(\"Excel fil\"=X1,\n         \"Antall formler\"=X2) %>% \n  print()\n\n\n#>                                      Excel fil Antall formler\n#> 1                           demo_workbook.xlsx              0\n#> 2                                 top2000.xlsx              0\n#> 3 UK Labour Market - Sickness and Absence.xlsx              0\n#> 4    Uk Labour Productivity - Time Series.xlsx              0\n#> 5          UK Public Service Productivity.xlsx              0\n\nMap istedenfor loops\nJeg skal nå viser dere hvordan alt det vi har gjort over kan gjøres\npå en enda mer effektiv og enklere måte. Vi utnytter purrr\nsine funksjonelle verktøy som tillater oss å gjøre eksakt det samme som\nvi ville gjort ved bruk av en loop, bare at vi trenger å skrive mye\nmindre kode.\nFørst vil jeg kjapt vise hva map gjør. Under tar jeg\nkvadratroten av alle tallene i sekvensen 1 til 10. Så den tar inn\nseq(1,10), som er det samme som et int-objekt. Det ville\nsett slik ut: int [1:10] 1 2 3 4 5 6 7 8 9 10 Videre\nutfører den funksjonen sqrt, som er en innebygget funksjon\nfor kvadratrot. x, √{x}.\n\n\nmap(seq(1, 10), sqrt)\n\n\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] 1.414214\n#> \n#> [[3]]\n#> [1] 1.732051\n#> \n#> [[4]]\n#> [1] 2\n#> \n#> [[5]]\n#> [1] 2.236068\n#> \n#> [[6]]\n#> [1] 2.44949\n#> \n#> [[7]]\n#> [1] 2.645751\n#> \n#> [[8]]\n#> [1] 2.828427\n#> \n#> [[9]]\n#> [1] 3\n#> \n#> [[10]]\n#> [1] 3.162278\n\nsteg 1\nVi må definere en formel. Dette er en generell formel, og kan brukes\ni realiteten for alle Excel ark videre. Den lagrer vi globalt i systemet\nvåres.\n\n\ncount_formulas <- function(workbook_name){\n  n_formulas <- xlsx_cells(workbook_name) %>%\n    filter(!is.na(formula)) %>% \n    nrow()\n  \n  data.frame(\"workbook\" = workbook_name,\n             \"n_formulas\" = n_formulas)\n}\n\n\n\nsteg 2\nDet neste vi gjør er å bruke map. Jeg skal vise dere to\nmåter. Den første er standard, men den gir en liste tilbake, som noen\nganger er konrglete å jobbe med.\n\n\nmap(list_xlsx, count_formulas)\n\n\n#> [[1]]\n#>             workbook n_formulas\n#> 1 demo_workbook.xlsx          0\n#> \n#> [[2]]\n#>       workbook n_formulas\n#> 1 top2000.xlsx          0\n#> \n#> [[3]]\n#>                                       workbook n_formulas\n#> 1 UK Labour Market - Sickness and Absence.xlsx          0\n#> \n#> [[4]]\n#>                                    workbook n_formulas\n#> 1 Uk Labour Productivity - Time Series.xlsx          0\n#> \n#> [[5]]\n#>                              workbook n_formulas\n#> 1 UK Public Service Productivity.xlsx          0\n\nDerfor finnes det en utgave av map som heter\nmap_dfr. Den gir oss eksakt det samme svaret som vi gjorde\nover, til og med har den fiksa kolonnenavnene for oss. Det er fordi jeg\nspesifiserte i funksjonen vi lagde over at kallenavnene skal være\nworkbook og n_formules. Det kan endres til hva enn som\npasser hvis man ønsker det.\n\n\nmap_dfr(list_xlsx, count_formulas)\n\n\n#>                                       workbook n_formulas\n#> 1                           demo_workbook.xlsx          0\n#> 2                                 top2000.xlsx          0\n#> 3 UK Labour Market - Sickness and Absence.xlsx          0\n#> 4    Uk Labour Productivity - Time Series.xlsx          0\n#> 5          UK Public Service Productivity.xlsx          0\n\nVidere kan man være mer interessert å finne ut av egenskaper. Feks\nønsker vi å vite hvilke filer har null formler i seg. Under legger jeg\ntil en liten ekstra linje. Og sier gi meg svarer hvor det er null\nformler.\n\n\nmap_dfr(list_xlsx, count_formulas) %>% \n  filter(n_formulas == 0)\n\n\n#>                                       workbook n_formulas\n#> 1                           demo_workbook.xlsx          0\n#> 2                                 top2000.xlsx          0\n#> 3 UK Labour Market - Sickness and Absence.xlsx          0\n#> 4    Uk Labour Productivity - Time Series.xlsx          0\n#> 5          UK Public Service Productivity.xlsx          0\n\nAngående loops\nDet er også scenario hvor det å faktisk skrive en klassisk loop er\nden beste løsningen. For eksempel hvis du jobber med en funksjon hvor\ndet n´e element avhenger av den n´e. Referanse\nklikk her\nI tillegg er det flere verktøy rettet mot loops. I denne artikkelen\nhar jeg fokusert på purrrr, men det er også\nfurrr. furrr\nReferanser\n\n\n\n",
    "preview": {},
    "last_modified": "2022-06-02T04:40:14+02:00",
    "input_file": {}
  },
  {
    "path": "posts/linker_mappe/",
    "title": "Sykt matriale",
    "description": "Samling og oppbevaring av ressurser oppdaget underveis.",
    "author": [
      {
        "name": "Lyder Aleksander Mathisen",
        "url": "https://onelyder.com/about"
      }
    ],
    "date": "2021-10-21",
    "categories": [],
    "contents": "\nmyweblibrary 4later\nPodcasts - Coding/Programming\nCoder Radio\nGoogle podcast\n\nCommand-line Heroes\nRedhat radio\n\nr-weekly -Apple\nShiny developer Series\nApple\nCodingblocks\nResources\nbrew\nR in General\nHADLEY WICKHAM\nrweekly\nrladies\nshinydevseries.com\nunleash-shiny.rinterface.com\nhttps://peertube.linuxrocks.online/videos/trending\nemilhvitfeldt.com\nWeb\nDestill\nGithub Guide\nhttps://distillery.rbind.io/\nhttps://www.jhelvy.com/\nDenne Githuben er sykt bra!\nhttps://ellakaye.github.io/distilltools/\nhttps://github.com/seankross/postcards\nHugo Web\nPage\nepirhandbook R\nbok\nLegendarisk bok om alt rundt R kode.\nhttps://user2021.r-project.org/\nRstudio Cloud\nPakker\ncheatsheets R pakker\nGenerelle standard\nhere fs git2r Tidyverse devtools pacman remotes renv\nData Manipulation/Formatting\ndplyr lubridate stringr purrr tidyr\nreadr readxl opsenxlsx vroom # import csv or tsv tidyxl rio # import\nall type of files janitor # ename collums\nrmarkdown i R:\nbookdown blogdown knitr rmarkdown bs4 # bootstrap theme bslib #\nthemes reprex # downlit # themes destill/rmkardown web tidytex # latex\npack for R articls # article templates rmarkdown postcards # themes\ndestill/web R distill # webpage rmarkdown kableExtra # kable print\nrmakrdown flextable # rmarkdown dashboard vtable # summary tables\nShiny\nshinyWidgets, dreamRs/shinyWidgets shinyjs, daattali/shinyjs\nshinydashboard, rstudio/shinydashboard shinydashboardPlus,\nRinteRface/shinydashboardPlus shinythemes, rstudio/shinythemes plotly,\nploty/ploty dygraphs, rstudio/dygraphs highcharter,\njbkunst/highcharter\nweb/html-output helpers:\njsonlite\nworkflow i R:\ntargets\ndrake\nAPI\nplumbr\n\n\n# Pakker jeg bruker \n\n##########################################\n# List of useful epidemiology R packages #\n##########################################\n\n# This script uses the p_load() function from pacman R package, \n# which installs if package is absent, and loads for use if already installed\n\n\n# Ensures the package \"pacman\" is installed\nif (!require(\"pacman\")) install.packages(\"pacman\")\n\n\n# Packages available from CRAN\n##############################\npacman::p_load(\n  \n  # learning R\n  ############\n  learnr,   # interactive tutorials in RStudio Tutorial pane\n  swirl,    # interactive tutorials in R console\n  \n  # project and file management\n  #############################\n  here,     # file paths relative to R project root folder\n  rio,      # import/export of many types of data\n  openxlsx, # import/export of multi-sheet Excel workbooks \n  \n  # package install and management\n  ################################\n  pacman,   # package install/load\n  renv,     # managing versions of packages when working in collaborative groups\n  remotes,  # install from github\n  \n  # General data management\n  #########################\n  tidyverse,    # includes many packages for tidy data wrangling and presentation\n  #dplyr,      # data management\n  #tidyr,      # data management\n  #ggplot2,    # data visualization\n  #stringr,    # work with strings and characters\n  #forcats,    # work with factors \n  #lubridate,  # work with dates\n  #purrr       # iteration and working with lists\n  linelist,     # cleaning linelists\n  naniar,       # assessing missing data\n  \n  # statistics  \n  ############\n  janitor,      # tables and data cleaning\n  gtsummary,    # making descriptive and statistical tables\n  rstatix,      # quickly run statistical tests and summaries\n  broom,        # tidy up results from regressions\n  lmtest,       # likelihood-ratio tests\n  easystats,\n  # parameters, # alternative to tidy up results from regressions\n  # see,        # alternative to visualise forest plots \n  \n  # epidemic modeling\n  ###################\n  epicontacts,  # Analysing transmission networks\n  EpiNow2,      # Rt estimation\n  EpiEstim,     # Rt estimation\n  projections,  # Incidence projections\n  incidence2,   # Make epicurves and handle incidence data\n  i2extras,     # Extra functions for the incidence2 package\n  epitrix,      # Useful epi functions\n  distcrete,    # Discrete delay distributions\n  \n  \n  # plots - general\n  #################\n  #ggplot2,         # included in tidyverse\n  cowplot,          # combining plots  \n  # patchwork,      # combining plots (alternative)     \n  RColorBrewer,     # color scales\n  ggnewscale,       # to add additional layers of color schemes\n  \n  \n  # plots - specific types\n  ########################\n  DiagrammeR,       # diagrams using DOT language\n  incidence2,       # epidemic curves\n  gghighlight,      # highlight a subset\n  ggrepel,          # smart labels\n  plotly,           # interactive graphics\n  gganimate,        # animated graphics \n  \n  \n  # gis\n  ######\n  sf,               # to manage spatial data using a Simple Feature format\n  tmap,             # to produce simple maps, works for both interactive and static maps\n  OpenStreetMap,    # to add OSM basemap in ggplot map\n  spdep,            # spatial statistics \n  \n  # routine reports\n  #################\n  rmarkdown,        # produce PDFs, Word Documents, Powerpoints, and HTML files\n  reportfactory,    # auto-organization of R Markdown outputs\n  officer,          # powerpoints\n  \n  # dashboards\n  ############\n  flexdashboard,    # convert an R Markdown script into a dashboard\n  shiny,            # interactive web apps\n  \n  # tables for presentation\n  #########################\n  knitr,            # R Markdown report generation and html tables\n  flextable,        # HTML tables\n  #DT,              # HTML tables (alternative)\n  #gt,              # HTML tables (alternative)\n  #huxtable,        # HTML tables (alternative) \n  \n  # phylogenetics\n  ###############\n  ggtree,           # visualization and annotation of trees\n  ape,              # analysis of phylogenetics and evolution\n  treeio            # to visualize phylogenetic files\n  \n)\n\n\n\nR-code & Packages\n\nmiltonfmr (quant-site)\nhttps://miltonfmr.com/complete-list-of-libraries-packages-and-resources-for-quants/\n\nTime-series\nhttp://www.time-series.net/\nFound this when I serched for material regarding VAR. Think I\nfirst found this link:http://www.fsb.miamioh.edu/lij14/ and this time-series\nvia that. It should be a lot of example and framework relatied things\nregarding R-code, finance, but also academic list and material…\nCode https://sites.google.com/view/davidgabauer/econometric-code\nGithub: https://github.com/GabauerDavid/ConnectednessApproach\nR-workbooks: https://sites.google.com/view/davidgabauer/use-rpython\nNotes: I have testet some of the source files and\nscripts, and it looks very nice! I finally have found a script that\ncointains functions and setups necesssary for forcasting matrix`s over\ndifferant time-periods. I have stored the files on my mac-PC.\nConnectednessApproach-master &\nfirefox_files & dy2012_copi are foldes\ncontaining source code on my desktop.\n\nropensci\nhttps://ropensci.org\nData, software & reproducibility\n\nPackages, functions\n& librarys available in R\n\nHere I will store packages I personally find usefull. These packages\nwill in general relate to datasience, finance and time seres modelling.\nBut also r-markdown and reproducable reaserch document\npackages.\nMaterial\n\nR-Markdown & Reproducable\nReasearch\nUlyngs (oxford template)\n-   <https://github.com/ulyngs/oxforddown>\nNTNU Latex og stil\nhttps://github.com/COPCSE-NTNU/master-theses-NTNU/tree/master/ntnuthesis\nhttps://www.math.ntnu.no/emner/TMA4268/2018v/1Intro/\n\nrstudioapi\nhttps://cran.r-project.org/web/packages/rstudioapi/rstudioapi.pdf\nbrukes feks til theme edit\n\nformatr\nhttps://yihui.org/formatr/#2-reformat-r-code\n\nBookdown\nhttps://bookdown.org/\nhttps://www.r-bloggers.com/2018/08/how-to-self-publish-a-book-customizing-bookdown/\nhttps://bookdown.org/ (alle bøkene)\n\n\nRiffomonasProject\nYoutube-Bruker: RiffomonasProject https://www.youtube.com/c/RiffomonasProject\n\n\nData Wrangeling\ntidyverse (General Package for\nData Sience)\nbook: https://r4ds.had.co.nz/\ndplyr\nreadr\nlubridate (time, dateobject)\nOverview of packages https://www.tidyverse.org/packages/\n\n\nNickCHK\nYoutube-Bruker: NickCHK\n\nR-Hubs: https://rpubs.com/NickCHK/\n\n\nStatistical/Econometric\nmodels\n(empirical oriented)\nMTS (VAR framework)\nTsay, R. S\nhttps://github.com/d-/MTS/blob/master/R/MTS.R\nbook: Tsay, R. S. (2014). An Introduction to Analysis of Financial\nData with R. John Wiley & Sons.\nTsay, R. S. (2013). Multivariate Time Series Analysis: With R and\nFinancial Applications. John Wiley & Sons.\n\nNTS (Nonlinear Time Series\nAnalysis)\nTsay, R. S\nhttps://faculty.chicagobooth.edu/ruey-s-tsay/research/nonlinear-time-series-analysis\n\nProf. Daniel P. Palomar (VAR/ARMA\nVingette)\nhttps://palomar.home.ece.ust.hk/MAFS6010R_lectures/Rsession_time_series_modeling.html\nhttps://cran.r-project.org/web/packages/portfolioBacktest/vignettes/PortfolioBacktest.html\n\nFinance, Risk,\nTimeseries, Optimization functions\nFinance View Cran\nAll finance-related packages on R (CRAN). Amazing.\nhttps://cran.r-project.org/web/views/Finance.html\n\nintrocompfinr\nLink\nIntrocompfin\n\nRmetrics (Framwork, several\npackages published)\nPDF-book Portfolio Optim: https://www.rmetrics.org/downloads/9783906041018-fPortfolio.pdf\nRmetrics fPortfolio vignette(GOOD) part 1 & 2:\nP1: https://miltonfmr.com/the-complete-guide-to-portfolio-optimization-in-r-part1/#rollstats\nP2: https://miltonfmr.com/the-complete-guide-to-portfolio-optimization-in-r-part2/\n\n\ntidyquant (Finance)\nlink: https://business-science.github.io/tidyquant/\n\nBLCOP (Black-Litterman model\nframework)\nlink: https://cran.r-project.org/web/packages/BLCOP/vignettes/BLCOP.html\ninstall: install.packages(“BLCOP”, repos=“http://R-Forge.R-project.org”)\nFound via: https://r-forge.r-project.org/R/?group_id=156\n\nQRMtools(general functions\nfinance)\nI found this on youtube sometime when I studied for my exams. I have\nstored the link ever since, very nice and powerful tools and knowledge\nsharing!\nhttps://cran.r-project.org/web/packages/qrmtools/vignettes/geometric_risk_measures.html\nhttps://www.qrmtutorial.org/r-code?fbclid=IwAR1Qnkkq9d_Gt28-ptQmTmLpbIcGNwMudKxYyKFONKgkfWoa8X8p1HIXLg4\n\n\nFRAPO\nhttps://www.pfaffikus.de/books/jwex2/\nhttps://www.pfaffikus.de/\n\nBlogroll: Finance & R-code\nFound this link via rgarch packages site on CRAN: http://www.unstarched.net/ via this link I found this\nlink http://www.unstarched.net/blog/ and violah: I came here\nhttps://www.portfolioprobe.com/2012/01/05/the-top-7-portfolio-optimization-problems/\nwhich gave me this blogroll https://www.thertrader.com/ with a nice vignette: https://www.thertrader.com/2017/06/04/linking-r-to-iqfeed-with-the-quanttools-package/\nThis is a good example of how quick, but also contentrich, the\nR-community, and especially for finance are!! There\nare so much interessting content, most likley written by the\nsmartest/best people, availible for free! This happends all the time\nwhen I am searching around looking for packages, functions or methods I\ncan use for my own project. I end up reading or studiung cases/\nfunctions that is not actuelly what I am suposed to do… The only\ndownside about R, is that you probebrly are going to burn out much of\nyour planned work hours. So stay orginzed, but also; take\nsome time enjoying what`s out there!! I am feeling blessed,\nreally.\nBLOG-ROLL\nThe R Trader\nlink: https://www.thertrader.com/\nr-bloggers\nlink: https://www.r-bloggers.com/\ndatacamp.\nlink: https://learn.datacamp.com/\nGenerelle Notes\nIn this section I indtend writing down my own personal “studing”\nnotes, and make space for chapters/parts for themes I find interessting\nwriting notes aboout. These notes are written during a typical working\nsesh, or just another day I find it interessting searcing around the\nAMAZING community for datasience resoruces!\nMy notes could be anything within the category of\ndatasience, modelling, finance and\nescpacially R. I want to gather my notes in one place(folder),\nin the hope of possible utizlizing a connection I suspect may excist\nbetween themes I learn about during my work sessions. Said in another\nway; You may find random themes and paragraphs here.\nFile types,\nhow to store them and key differences\nIt dosent matter what kind of analyst you are trust me. R, Python,\nJava, C, C++, S or wathever; file-types and folderstructure is key if\nyou want to master, or just even use code and programming-languages\nefficient. As a result of that, I indtend storing my own personal notes\nfrom studiong/resarching about filetypes I have often met when I have\ncoded/worked on my own personal prosjects.\nI have felt both the frustration and the irritation of not\nunderstanding/taking enough time understanding what Its really all\nabout. As a matter of fact, If you dont understand how the algoritm\nlikes he`s food served.. you actuelly deserve beeing tortured by error\nmessages. At least coused from not handling your files proper. It may\nsound wierd, but it could exist a kind of relashionship between\nalgortims and humans in the sens of treting whats deare in the proper\nway. File and data is the maintance for the script!!!\nBelow I write down extention-names on filetypes I recollect on the\ngo. If the [] box is emtpty, it means I have not started researching\nproperly yet.\n\nCSV[x]\nXLS[x] zip[] gz[]\ntsv[] txt[]\n\nCSV -> stores the data as text. Can only store\nthe values, not formatting and formulas etc. \nXLS -> stores data binary file. Readable for\nthe computer. Can store values, formatting……\nMATERIAL FEEDER\nHere I will “feed” the block with links, notes, refs and material I\nexplore. These need to be placed in the right sections. This part is\nthen not included in the official “document” and will be removed when\nthere`s eventuelly no more links to feed. I have placed this feed-block\non the top of the document so I can easily see it, and start sortering\nwhen i begin a work section.\nfile:///C:/Users/lyder/Desktop/Bibliography-/Notes/bookmarks_7_15_21.html\nORGANISER DETTE!\n## Linker\nhttps://libraries.io/cran/RefManageR\n\nhttps://books.ropensci.org/drake/index.html\n\nhttps://www.youtube.com/watch?v=jU1Zv21GvT4&t=4055s\n\nhttps://www.rstudio.com/resources/rstudioglobal-2021/maintaining-the-house-the-tidyverse-built/\n  \nhttps://docutils.sourceforge.io/docs/ref/doctree.html#image\n\nhttps://books.ropensci.org/drake/index.html\n\n  \n  \n## PDF\nR-litteratur: mappe skrivebordet!!\n\nHar også sett på apperence_themes: shiny. \n\nIntro (START)\nThis document contains notes, links, referances and matarial I have\nused throughout the prosses.\n\n\n\n\nRefs to my own work\nstored some_where\nOutput github “test” https://github.com/lyder7/thesis-rasp/blob/master/r-markdown/test-html/test.md\nDenne har bilder, og formattering slik som html versjonen hadde.\nFant denne linken via thesis-rasp\n\nResultater lagret i txt dokument https://github.com/lyder7/thesis-rasp/blob/master/r-markdown/test-html/resultater.txt\ntest.Rmd https://github.com/lyder7/thesis-rasp/blob/master/r-markdown/test-html/test.Rmd\ngenerelt lagret https://github.com/lyder7/thesis-rasp/tree/master/tekst\n\n\n",
    "preview": {},
    "last_modified": "2022-02-19T03:18:48+01:00",
    "input_file": {}
  }
]
