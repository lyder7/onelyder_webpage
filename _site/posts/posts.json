[
  {
    "path": "posts/rfunkskjoner/",
    "title": "R programmering",
    "description": "Purrr::map(). Last Updated: 2022-07-14 13:59:43",
    "author": [
      {
        "name": "Lyder Aleksander Mathisen",
        "url": {}
      }
    ],
    "date": "2021-11-24",
    "categories": [],
    "contents": "\n\nContents\nFunksjonell programmering i\nR\nViktige basis konsepter\nSymboler\nLogiske sjekkpunkter\nLoops\n\nTidyverse\nOppsett\nPurrr\nFunksjoner jeg har laget\nselv\n\nSideeffetcs\nEgne funksjoner\nLage\n\nrlang\nNoen tips\n\nC++ og R?\nNest\n\n\nAppendix\nOversikt\nover sentrale tidyverse pakker. Kartlegge bruksområder.\nBasis: Vektorer &\nstrukturer i R\nBasis: String\nfunksjoner sentrale\n\n\n\nFunksjonell programmering i\nR\nViktige basis konsepter\ntidyverse og med alle data science verktøyene til R\nbrukere, er det allikevel etter min mening viktig å lære de fundamentale\nrammene. “base R” (Wickham and Grolemund\n2016; “Tidyverse” n.d.).\nFlere standard-pakker . utils, stats,\nmethods, grDevices, graphics og\ndatasets.\nFra R-studio kan man få en oversikt over pakkene, og se\nhva dem inneholder. Hvis man går til vinduet og klikker på menyen som\nheter “Enviroment”. Der vil det stå “Global\nEnviorment”. Trykk på rull gardinen og det vil komme frem en\noversikt over pakkene jeg nevnte over. Velg for eksempel\nbase.\nDet er mulig å redigere hvordan informasjonen vises. Helt til høyre i\nvinduet er det en ny rullegardin med en pil som peker ned, siden av\noppdater-symbolet. Grid og List er alternativene. Personlig foretrekker\njeg den første, fordi den viser informasjon over flere kolonner.\nFra oversikten kan du undersøke hvilke funksjoner som er\ntilgjengelig. Man kan også se kilde-koden. Muligheten til å se hvordan\nfunksjonene er bygget, nyttig når man utvikler ferdighetene innenfor\nprogrammering. Kilde koden gir muligens svaret man trenger for å\nkonkretisere eller gi en klar definisjon på hvordan funksjoner\nfungerer.\nLink\nBase R\nInne i R-studio, finn library. Åpne funksjonen.\nDet gir et perspektiv om hva som ligger bak funksjonene som brukes\nregelmessig.\nSymboler\nNotasjoner & symboler nyttig å lære. Bruken av disse kan\npotensielt gjøre funksjonene du skriver enda mer dynamiske og sterke.\nHer er noen av de symbolene jeg personlig ønsker å lære mer om:\ndo.call(function_name, object_name)\n%>% –> margitrrr.\nKjede-operator.\n%in%\n\\n\n\\t\n[[ ]] –> vektor\n[ ] –> list\nLogiske sjekkpunkter\nifelse base\nif_else dplyr\nall() base. Kan brukes på flere\nmåter:\nalene all(logical0==)) if(all(0)) –> Hvis alle\nverdiene definert av funksjonene så skjer:\n\n\nobject_a = NULL\nobject_b = NULL\nif(all(object_a == object_b)){\nprint(\"the objects are the same\")\n} else {\n peint(\"they are not true\")\n}\n\n\n#> [1] \"the objects are the same\"\n\nNB!! Husk at vi kan “tweake” funksjonen slik:\n\n\nobject_a = NULL\nobject_b = NULL\nif(!all(object_a == object_b)){\nprint(\"hello worlt\")\n} else {\n print(\"statemant not true\")\n}\n\n\n#> [1] \"statemant not true\"\n\nDet er også mulig å gjøre flere justeringer av funksjonen. Over skrev\nvi kun else, som vil si at hvis if-statementen\nførst resulterer i FALSE, så vil den gå over til neste\noppgave som er definert etter\nelse {\n}\nLiten endring:\nSkriver else if () fordi programmet vurderer en ny\nlogisk test før den utfører en spesiell type oppgave. For å kontrollere\nfunksjonens rute. Ofte nødvendig med av klaringer, om noe avviker (det\ntestes for i if utsagnene) vil programmet håndtere.\nOgså kontrollflyt. Noen blokker viser else if\nvarianten:\n\nobject_a = NULL\nobject_b = NULL\n# 1\nif(all(object_a == object_b)){\nprint(\"the objects are the same\")\n} else if{\n print(\"they are not true\")\n}\nobject_a = NULL\nobject_b = TRUE\n# 2\n if(!all(object_a == object_b)){\nprint(\"hello worlf\")\n} else if( {\n print(\"statemant not true\")\n}\n\nNB!!\n* else må være på lik linje med den siste brakken\n{ for at R skal kunne evaluere den.\nLogic\ncheckpoints\nI utgangspunktet kan man fint bruke funksjoner som allerede finnes i\npakker. Som regel er de aller fleste pakkene innenfor ulike\nfagfelt/emner store i omfang, slik at de dekker de fleste verktøyene man\nvil trenge for en analyse f.eks.\nSannsynligheten for at et problem som ikke helt kan løses med pakken\ndu bruker, er funksjons bygging løsningen!\nKonseptet x <-\n\"hva_som_helst\". Tekst, tall, en funksjoner etc. i en\n“system variabel” x. Lagrer variabelen som en funksjon, og\nkan i prinsippet bestå av hva som helst.\nLoops\nEksempel\npurrr\nEksempelet under viser et vanlig scenario hvor loops er\nnaturlig å bruke. Målet er å telle antall bokstaver i hvert navn i\nvektoren navn.\nGod praksis er å gjøre klart objektet resultatene skal lagres i. Her i\neksempelet under er det antall bokstaver i hvert navn.\n\n\nnavn <- c(\"Lyder\", \"Aleksander\", \"Mathisen\")\nn_ord <- vector(\"double\", length(navn)) # Expecting double\n\n\n\nVidere lager vi en loop, den utfører operasjonen i en og\nsamme “kode blokk”. Årsaken til at *loops** er nyttig her, er fordi man\nønsker å unngå reputasjon. Loopen gjør oppgaven vi spesifiserer på alle\nelementene i vektoren. Vi trenger bare å skrive en “blokk” med kode.\n\n\nfor(i in seq_along(navn)) {\n  n_ord[[i]] <- stringr::str_extract(navn[[i]], \"\\\\w\") \n}\nn_ord\n\n\n\nFor hvert element i, i antall sekvenser i vektoren \\(`navn`\\), utfør funksjonen\nstr_extraxt() på objektet navn[]indeks\ni, lagre resultatet i objektet \\(`n_ord`\\) indeks \\(`i`\\).\nResultatet er altså: vi får et objekt n_ord bestående av\nantall bokstaver (resultatet) for hvert navn. I dette tilfellet er det 3\nnavn, som bestyr 3 resultater.\npurrr::map\nEksemplet over viser hvordan loops kan utføres. Dette er den\ntradisjonelle måten å gjøre det på. Man kaller det ofte “basis R\nforloops”.\nKonseptet loops1 innenfor programmering generelt sett\ner et viktig og veletablert tema eller konsept. For språk som C, C# og\nC++ eller Python er loops spesielt “the way” og på mange måter\nen del av flyten i språket for de som bruker det som deres nummer1\nspråk.\nC++ er feks kjent som det aller raskeste og effektive språket. Særlig\nfor oppgaver hvor loops er nyttig. For R derimot er det spesielt for\nkritikere av R, et godt etablert sannhet at loops går tregt.\nSammenlignet med da feks C++.\nSå klart har det i realiteten ingenting å si for små prosjekter eller\nanalyser. Men satt i perspektiv; det er ikke effektivt å skrive loops i\nR.\nÅrsaken er kompleks og mer sammensatt til å forklare det enkelt og\nintuitivt. Men det har rot i hvordan syn-tak-strukturen i R er bygget\nopp, og antall linjer/bokstaver, samt objekter som er nødvendig å skrive\nfor å utføre funksjoner eller representative operasjoner.\nLøsningen på dette problemet er purrr fra\ntidyverse pakken for R.\npurrr er en pakke som tar for seg funksjonell\nprogrammering spesifikt med R-kode. Pakken har utviklet konsepter og\nmetoder som gjør at vi faktisk kan utføre oppgaver og operasjoner hvor\nloops i utgangspunktet hadde vært en del av løsningen. Du kan betrakte\ndet som en måte å gjøre loops på, uten å skrive loops. Merkelig\nnok..\nDet du isteden burde gjøre for å forstå dette konseptet er å tenkte\npå representative operasjoner som skal gjøres for alle elementene i\nobjektet. Altså at noe skal utføres flere ganger på flere ulike\nelementer innenfor et objekt vi undersøker/analyserer. 2\npurrr::map:\nforskjeller\ni in seq_along(object) erstattes med .x\nmap utfører loopen med hensyn til hva slags\nclass .x er.\nVektor, data.frame eller liste er derfor av\nbetydning!\n{ body }erstattes med .f\nfunksjonen eller oppgaven som skal utføres\nmap()er hovedfunksjonen.\nMen det er noen hjelpere for å garantere/kontrollere output:\nmap_dbl()\nmap_chr()\nmap_int()\nmap_dfr()\nwalk()\nTidyverse\nI dette kapittelet er formålet å bli bedre kjent med\npurrr og scenarioer hvor purrr kan være nyttig\nå bruke. Referanser til tidy og purrr se Wickham and Grolemund (2016) og\nWickham (2019a).\nPurrr er en pakke fra Tidyverse paradigme som hjelper\ntil med funksjonelle operasjoner (Wickham\n2019a).\nPrinsippene bak tidy filosofien og biblioteket\npurrr bistår oss med muligheter til å utføre operasjoner\neffektivt. Alternativet er å skrive egne funksjoner.\nRisikoen med egne funksjoner er at den kan bli for komplisert og\nspesifikk for prosjektet/settingen funksjonen lages for. I praksis betyr\ndet at funksjonen ikke kan videreføres til andre prosjekter eller\nproblemstillinger. Over tid og ved gjenbruk på andre data sett kan den\ngi resultater som muligens er feil (@\nWickham\n2019a; “6 Functions \nAdvanced R” n.d.).\nOppsett\nTil å starte med laster vi inn tidyverse. Alternativ er det også\nmulig å laste inn purrr ved library(purrr).\n\n\nlibrary(tidyverse)\n\n\n\nVidere trenger vi et datasett som vi kan bruke underveis. I\ntidyverse pakken finnes et datasett som heter\niris. Dersom tidyverse er lastet inn er det mulig å referere\ntil datasettet. Det har vi allerede gjort, og av den grunn lagrer jeg\niris under navnet data_iris. Se kodesnipp under:\n\n\ndata_name <- iris %>% \n  as_tibble()\ndata_name \n\n\n#> # A tibble: 150 × 5\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#>          <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n#> 1          5.1         3.5          1.4         0.2 setosa \n#> 2          4.9         3            1.4         0.2 setosa \n#> 3          4.7         3.2          1.3         0.2 setosa \n#> 4          4.6         3.1          1.5         0.2 setosa \n#> 5          5           3.6          1.4         0.2 setosa \n#> 6          5.4         3.9          1.7         0.4 setosa \n#> # … with 144 more rows\n\nKoden over viser hvordan data-settet “iris” kan refereres til etter\nat tidyverse er lastet inn. Videre ser vi at iris blir lagret i en\nvariabel vi kaller data_name. I prinsippet kunne vi valgt å\n“døpe” datasettet til noe annet. Og til slutt ser vi at de 10 første\nradene i datasettet kommer frem når vi skiver data_name til\nkonsollen. Her er formålet å få et kjapt overblikk over hvordan data ser\nut.\nPurrr\npurrr::map\nFor å bli kjent med data er det fra base R vanlig å\nutføre funksjonen class(). Den gir tilbake informasjon om\nhvilke klasser datasettet består av. Dersom vi utfører\nclass(data_name) får vi som output\ndata.frame. Det er fordi class()\nfunksjonen kjøres på objektet data_name som\nhelhet. Noen ganger kan det være nyttig å få informasjon om hver\nvariabel, som blir det samme som hver kolonne i et data sett.\nEn løsning er å gjøre slik:\nclass(class(data_name$Sepal.Length)) eller\nclass(data_name[,1]). Ulempen med denne måten er at den er\ntreg og lite effektiv. For å sjekke neste kolonne må vi skrive\nclass(data_name[,2]) etc. helt frem til vi har testet alle\nvariablene vi er interessert i. I praksis vil det være alle kolonnene i\net datasett.\nMed purrr pakken kan vi sjekke alle kolonne med en\nfunksjon og en linje med kode. Tilbake gir den oss en vektor med\nresultatet fra alle variablene/ kolonnene i datasettet som vi har lagret\nsom data_name. Se under:\n\n\nmap_chr(data_name, class)\n\n\n#> Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species \n#>    \"numeric\"    \"numeric\"    \"numeric\"    \"numeric\"     \"factor\"\n\nÅrsaken til at vi bruker map_chr er fordi konsollen blir\nfremvist i et objekt lagret som character\nclass. Til vanlig og som defoult lagres output fra\nmap() funksjoner i lister. Det vil si at vi kan gjøre\nakkurat det samme med denne syntaksen:\n\n\nmap(data_name, class)\n\n\n#> $Sepal.Length\n#> [1] \"numeric\"\n#> \n#> $Sepal.Width\n#> [1] \"numeric\"\n#> \n#> $Petal.Length\n#> [1] \"numeric\"\n#> \n#> $Petal.Width\n#> [1] \"numeric\"\n#> \n#> $Species\n#> [1] \"factor\"\n\nMen her får vi resultatet lagret i en liste. Lister er mer komplisert\nå jobbe med, og er generelt vanskeligere å referere til i etterkant.\nDerfor ønsker vi å gjøre det så enkelt som mulig, å dermed bruke\nmap_chr() som lagrer det for oss i en\ncharacter class.\nVi kan også lagre konsollen og referere til den i etterkant hvis vi\ntrenger det. Under gjør vi eksakt samme operasjon, utfører\nclass() funksjonen til alle variablene i datasettet\ndata_name. Vi lagrer resultatet i\ndata_name_classes. Videre bruker vi pipe fra\nmagrittr til å utføre funksjonen glimpse() som\ngir oss en oppsummering-tabell av innholdet. Se under:\n\n\ndata_name_classes <- map_chr(data_name, class)\ndata_name_classes %>% \n  glimpse()\n\n\n#>  Named chr [1:5] \"numeric\" \"numeric\" \"numeric\" \"numeric\" \"factor\"\n#>  - attr(*, \"names\")= chr [1:5] \"Sepal.Length\" \"Sepal.Width\" \"Petal.Length\" \"Petal.Width\" ...\n\nLogikken med map er at den tar inn noen viktige input i\nfunksjonen. Den etterspør .x og .f\n.x = en vektor funksjonen skal utføres på\n.f = valgt funksjon.\nVårt tilfelle er .x = data_name og\n.f = class .\nimap, pmap\nFunksjoner jeg har laget\nselv\nI denne delen tar jeg for meg egne funksjoner og skisser skrevet av\nmeg selv. Målet er å videre utvikle dem og sette de til verks.\n\n\n#Info om hvilken mappe data ligger i + navn p? sheets \npath <- \"data_raw/transaksjoner.xlsx\"\nsheets <- readxl::excel_sheets(path)\n## Alle sheets i excelark er data.frames\npurrr::walk(\n  .x = excel_sheets(path),\n  .f = function(x) {\n    new_nm <- tolower(x)\n    assign(new_nm, read_excel(path, sheet = x), envir = .GlobalEnv)\n  }\n)\n\n\n\nBryte ned til flere deler er nok lurt å gjøre.\n1 består av data inn. Det kan være et excel ark med flere sheets som er\naktuelt. Fra mitt eksempel kan det være regnskapsdata bestående av\nkolonner med tall, tekst og dato. Ofte er disse filene store for\nselskaper i en visse størrelser. Vi ønsker derfor å laste inn data slik\nat hver flik blir ett data.frame objekt i R, som kan brukes\nvidere.\n\n# nest kan være neste steg. HVer data.frame er ett element i samme liste. Bruke det til å refere til for en loop-opperasjon. \n# Her er hva jeg tenker vist med en for looop:\nfor(i in seq(walk_object)){\n  \n  df[[i]] <- walk_object[[i]]\n  \n  a <- df\n  \n  if(!class(df)){\n    \n    # Data formattering starter\n    a <- a %>% \n      \n      \n      # Data frame class\n      tidyr::as_tibble()\n    \n      if(is.na(NA) = TRUE){\n        \n        drop_na(a)\n      }\n    \n    else{\n      \n      \n      \n      \n      \n    }\n      return(a)\n    \n  }\n  # freq antall varaibler/kolonner\n  if(count_(names(a)) == freq){\n    \n      kolonne_nanv <- names(a)\n      \n      # Velg kolonner \n      select(all_of(kolonne_navn)) %>% \n        \n      arrange(desc(.x)) %>% \n      \n      ##lage kolonne med diff \n      mutate(endring_periodeV = (data2021 - data2020))\n  }\n      if(desc(.x)) {\n        drop_na(NA %==% .x) %>%\n          else {\n            return(navn_her)\n            \n          }\n          mutate()\n      }\n      \n      drop_na(NA %==% .x) %>% \n      \n      \n      ## Regnskapskontoer i SB\n      \n    mutate(str_glue(konto_navn) == filter(vroom::starts_with(kolonne_navn)))\n      \n  }\n}\n# Dette kan gjøres med purrr og tidyr \ntidyr::nest()\n\nNeste steg er å generalisere operasjonene som skal gjøres Excel\narkene. Første spørsmål: er operasjonen lik for alle data-sett og\nalle kolonner?\npurrr erstatter loops laget selv\ndplyr for manipulering\nstringr for tekst\ntidyr for modellering, spesielt lister\nSideeffetcs\nWalk funksjonen til purrr er en variant som brukes når\nfunksjonen implementert har/ikke en output type som kalles\nsideeffekt. Output generelt kan beskrives i form av utsende;\ntabell, tall og annen tekst som er resultatet fra en operasjon utført\nvia en funksjon som i sum utfører en rekke betinget rekkefølge med\nkommandoer og andre underliggende funksjoner som skaper objekter eller\nresultater, som printes ut i sin form i konsollen. Det betyr at vi kan\nse hva resultatet er, i form av konsoll-tekst.\nMotsetningen er at vi har funksjoner som gir output uten side\neffekter. Her gjør funksjon operasjoner som er utenfor dens “scope”.\nEksempler er ploter eller genereringen av excel-sheets til en\nny arbeidsbok som lages i R.\nDisse resultatene, fra ikke siden-effekt funksjons typer er at man\nikke kan lagre resultatet i et objekt som kan refereres til i etterkant.\nOutput er til motsetning slik at den vises frem i konsollen i en mer\nfysisk form. Enten som en graf, plot.\nÅrsaken til at dette er viktig å få med seg, er fordi output og hva\nfunksjoner vi faktisk bruker, er utrolig viktig for å programmere\neffektivt.\nF.eks med funksjonen addWorksheet funksjonen, så gir den\ningenting av output. Den endrer noe “utenfor scopet”.\nEgne funksjoner\nI dette kapittelet tar vi et steg videre. Jeg vil forsøke å vise- og\nlære hvordan man kan lage sine helt egne funksjoner. I prinsippet er\nalle funksjoner mulig å lage. Funksjoner har en fast form som vi skal se\nnærmere på her. Hvis denne formen følges, er det som et utgangspunkt opp\ntil deg som forfatteren av funksjonen, hva den skal bestå av.\nI de første kapitalene var vi innom det grunnleggende konseptet hvor\nman ved bruk av <- eller = kan “lagre” data\ni objektet som vi selv velger hva skal hete. a <- 1 for\neksempel. Det vil si a representerer tallet 1,\nrefererer vi til objektet a, vil R tolke dette som\n1.\nLage\nI utgangspunktet er det flere tusen funksjoner tilgjengelig som kan\nbrukes. Som regel vil man komme langt med disse. Men som regel er det\nnoen særtrekk med akkurat ditt problem, som funksjonen i pakken ikke\nevaluerer slik du ønsker. Det kan være flere grunner til det, men en\ntypisk årsak til å skrive egne funksjoner kontra bruke andre sine, er\nfor å tilpasse funksjonaliteten til problemet som du skal løse. Det er\nmest sans behov for noen “tweaks” og små justeringer. Men det kan også\nvære tilfellet hvor det ikke finnes noe fra før, så man skriver hele\nfunksjonen- og kanskje en hel pakke, for å løse problemet.\nJeg tar derfor først for meg standardiserte funksjoner som er\nspesielle og egnet til å bruke i nye funksjoner også.\nrlang\nFor å gå litt dypere til verks for å forstå hva salgs hjelpemidler og\nfunksjoner som er i pakkene jeg personlig bruker til funksjoner og\nfunksjonell programmering i R. I kodesnippen under tar jeg å henter ut\nfunksjonsnavnene i pakken rlang, magrittr, og\npurrr (Mailund\n2019; Wickham 2019b; Wickham and Grolemund 2016). Jeg lagrer\ndisse i et objekt, og sammenligner dem mot hverandre.\n\n\npac <- pacman::p_functions(package = \"rlang\") %>% \n  as_vector() \n \npur <- pacman::p_functions(package = \"purrr\") %>% \n  as_vector()\nmag <- pacman::p_functions(package = \"magrittr\") %>% \n  as_vector()\n\n\n\n\n\ndf <- cbind(pac, pur, mag) %>% \n  as_tibble() %>% \n  glimpse()\n\n\n#> Rows: 434\n#> Columns: 3\n#> $ pac <chr> \":=\", \"!!\", \"!!!\", \".data\", \".env\", \"%@%\", \"%@%<-\", \"%<~…\n#> $ pur <chr> \"%@%\", \"%>%\", \"%||%\", \"accumulate\", \"accumulate_right\", …\n#> $ mag <chr> \"%!>%\", \"%<>%\", \"%>%\", \"%$%\", \"%T>%\", \"add\", \"and\", \"deb…\n\nÅrsaken til denne sammenligningnen er for å indentifisere nyttige\nkontroll-funksjoner vi kan bruke når vi bygger opp våre egne. Logiske\nfunksjoner som er TRUE eller FALSE er et velkjent konsept for\nprogrammerere. Det brukes til å kontrollere flownen og det som skjer\ninne i {}.\nSom nevnt tidligere er R og andre språk avhengig av rekkefølgen på\nhvordan ting gjøres. Resultatet av noe, vil påvirke et objekt, som vil\nha konsekvenser for videre flyt. For å hindre at feil objekter, eller\ndata typer taes inn videre, gjør man derfor\nif statement.\nDet vil si at inne i funksjonen vil det være en egen if evaluering.\nDersom den logiske testen = TRUE vil den slippe inn i brakke t4egenne.\nDersom FALSE hopper den over denne delen.\n\n\nfunction(x){\n  if(is.character(x)){\n  \n  }\n  return(x)\n}\n\n\n\nSom kode snippen viser over, er det altså en egen seksjon som er\nbetinget av if testen.\nNoen tips\n\n\n# Lager en vektor med elemtener\nvector <- c(\"Lyder\", \"Aleksander\", \"Mathisen\")\n# Lønsing 1 \n\"Lyder\" %in% vector\n\n\n#> [1] TRUE\n\n#Løsning 2\nany(vector == \"Lyder\")\n\n\n#> [1] TRUE\n\nany(vector == \"Henrik\")\n\n\n#> [1] FALSE\n\nKode snippen viser et typisk scenario hvor vi ønsker å sjekke om en\nvector består av en spesifikk verdi. I tilfellet jeg skrev over laget\njeg bare en vektor bestående av navnet mitt. Det vil si det er tre\nseparate elementer i vektoren. Under, løsning 1, tester jeg om “Lyder”\ner i vektor. Svaret er TRUE. Men et tips er å bruke løsning 2. Den gjør\ndet samme, men er mer effektiv og standardisert. Det er derfor best\npractice å ta i bruk denne. Resultatet blir TRUE her også. Nederst tok\njeg med evaluering av et element som ikke er en del, bare for å vise at\ndenne resulterer FALSE.\nC++ og R?\nNoen spesifikke operasjoner er mer effektivt å gjøre med C++. R har\ngode løsninger som kobler språkene sammen, slik at det mest nødvendige\noppgavene kan kjøres i C++ program, men hvor det allikevel skrives i R\nstudio slik du er vant til. Pakken Rcppfikser dette for\noss. Under trekker jeg ut funksjoner:\n\n\nlibrary(Rcpp)\npacman::p_functions(package = \"Rcpp\")\n\n\n#>  [1] \".__C__C++Class\"             \".__C__C++Constructor\"      \n#>  [3] \".__C__C++Field\"             \".__C__C++Function\"         \n#>  [5] \".__C__C++Object\"            \".__C__C++OverloadedMethods\"\n#>  [7] \".__C__Module\"               \".__C__RcppClass\"           \n#>  [9] \".__T__.DollarNames:utils\"   \".__T__[:base\"              \n#> [11] \".__T__[[<-:base\"            \".__T__[<-:base\"            \n#> [13] \".__T__$:base\"               \".__T__$<-:base\"            \n#> [15] \".__T__formals<-:base\"       \".__T__initialize:methods\"  \n#> [17] \".__T__prompt:utils\"         \".__T__show:methods\"        \n#> [19] \".DollarNames\"               \"compileAttributes\"         \n#> [21] \"cpp_object_dummy\"           \"cpp_object_initializer\"    \n#> [23] \"cppFunction\"                \"demangle\"                  \n#> [25] \"evalCpp\"                    \"exposeClass\"               \n#> [27] \"formals<-\"                  \"getRcppVersion\"            \n#> [29] \"initialize\"                 \"LdFlags\"                   \n#> [31] \"loadModule\"                 \"loadRcppClass\"             \n#> [33] \"loadRcppModules\"            \"Module\"                    \n#> [35] \"populate\"                   \"prompt\"                    \n#> [37] \"Rcpp.package.skeleton\"      \"Rcpp.plugin.maker\"         \n#> [39] \"RcppLdFlags\"                \"registerPlugin\"            \n#> [41] \"setRcppClass\"               \"show\"                      \n#> [43] \"sizeof\"                     \"sourceCpp\"\n\nNest\ntidyr::nest()\nAppendix\nOversikt\nover sentrale tidyverse pakker. Kartlegge bruksområder.\nBasis: Vektorer & strukturer\ni R\nKonsepter du må forstå eller akseptere for å beherske funksjoner,\nloops og representative operasjoner med R kode.\njennybc.github.io/purrr-tutorial\nVektor\nSamme klasse, en eller flere.\nData.frame\nSamling av flere vektorer, som vi kaller kollonner, bestående av\nsamme eller ulike type klasser i hver vetkor/kolonne.\nList\nFlere eller samme klasse i vektorene, kompleks.\nBasis: String funksjoner\nsentrale3\nPrinte for eksempel navnet til en funksjon, en operasjon eller en\nindeks som referanse. Type output paste og\npast0. 4\npaste()\npaste0()\n\n\n\n“6 Functions  Advanced\nR.” n.d. Accessed June 18, 2022. https://adv-r.hadley.nz/functions.html.\n\n\nMailund, Thomas. 2019. “Functional Programming:\nPurrr.” In R Data Science\nQuick Reference: A\nPocket Guide to APIs,\nLibraries, and Packages, 83–107.\nBerkeley, CA: Apress. https://doi.org/10.1007/978-1-4842-4894-2_6.\n\n\n“Tidyverse.” n.d. Accessed September 10, 2021. https://www.tidyverse.org/.\n\n\nWickham, Hadley. 2019b. Advanced R. Second\nedition. Boca Raton: CRC Press/Taylor & Francis Group.\n\n\n———. 2019a. Advanced r. chapman; hall/CRC.\n\n\nWickham, Hadley, and Garrett Grolemund. 2016. R for Data Science:\nImport, Tidy, Transform, Visualize, and Model Data. First edition.\nSebastopol, CA: O’Reilly.\n\n\nloops, foreloops, whileloops,\nnestetloops etc.↩︎\nUnngå missforståelser forbundet med\n“loops”. Tenk på det som noe vi skal utføre flere ganger på forskjellige\nenheter.↩︎\nBrukes inne i funksjoner gjennom å\nprinte f.eks navnet til en funksjon, operasjon eller indeks som\nreferanse.↩︎\nString manipulator. Typiske\noppgaver som slå sammen to navn, separere ett ord til to ord, skille to\nord med en valgt symbol \"\\\\ \" etc. er eksempel på\nscenarioer disse brukes.↩︎\n",
    "preview": {},
    "last_modified": "2022-07-14T13:59:46+02:00",
    "input_file": {}
  }
]
